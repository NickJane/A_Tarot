<?xml version="1.0"?><DTS:Executable xmlns:DTS="www.microsoft.com/SqlServer/Dts" DTS:ExecutableType="SSIS.Package.2">
<DTS:Property DTS:Name="PackageFormatVersion">3</DTS:Property>
<DTS:Property DTS:Name="VersionComments"></DTS:Property>
<DTS:Property DTS:Name="CreatorName">JianJialin-PC\JianJialin</DTS:Property>
<DTS:Property DTS:Name="CreatorComputerName">JIANJIALIN-PC</DTS:Property>
<DTS:Property DTS:Name="CreationDate" DTS:DataType="7">1/12/2012 10:18:21 AM</DTS:Property>
<DTS:Property DTS:Name="PackageType">5</DTS:Property>
<DTS:Property DTS:Name="ProtectionLevel">2</DTS:Property>
<DTS:Property DTS:Name="MaxConcurrentExecutables">-1</DTS:Property>
<DTS:Property DTS:Name="PackagePriorityClass">0</DTS:Property>
<DTS:Property DTS:Name="VersionMajor">1</DTS:Property>
<DTS:Property DTS:Name="VersionMinor">0</DTS:Property>
<DTS:Property DTS:Name="VersionBuild">17</DTS:Property>
<DTS:Property DTS:Name="VersionGUID">{096C7FAC-9840-451A-83F9-A746A1D5571E}</DTS:Property>
<DTS:Property DTS:Name="EnableConfig">-1</DTS:Property>
<DTS:Property DTS:Name="CheckpointFileName"></DTS:Property>
<DTS:Property DTS:Name="SaveCheckpoints">0</DTS:Property>
<DTS:Property DTS:Name="CheckpointUsage">0</DTS:Property>
<DTS:Property DTS:Name="SuppressConfigurationWarnings">0</DTS:Property>
<DTS:ConnectionManager>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">localhost.Tarot.sa</DTS:Property>
<DTS:Property DTS:Name="DTSID">{C66B6D20-0808-44B0-9B6A-CEFCBD06B0A2}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName">OLEDB</DTS:Property><DTS:ObjectData><DTS:ConnectionManager>
<DTS:Property DTS:Name="Retain">0</DTS:Property>
<DTS:Property DTS:Name="ConnectionString">Data Source=localhost;User ID=sa;Initial Catalog=Tarot;Provider=SQLNCLI10.1;Application Name=SSIS-UpdateSqlFromMongo-{C66B6D20-0808-44B0-9B6A-CEFCBD06B0A2}localhost.Tarot.sa;Auto Translate=False;</DTS:Property></DTS:ConnectionManager></DTS:ObjectData></DTS:ConnectionManager>
<DTS:Configuration>
<DTS:Property DTS:Name="ConfigurationType">1</DTS:Property>
<DTS:Property DTS:Name="ConfigurationString">D:\SSisPackage\UpdateSqlFromMongo\UpdateSqlFromMongo.dtsConfig</DTS:Property>
<DTS:Property DTS:Name="ConfigurationVariable"></DTS:Property>
<DTS:Property DTS:Name="ObjectName">配置 1</DTS:Property>
<DTS:Property DTS:Name="DTSID">{6B16F753-F059-4263-BF1C-6E9A4C7E080C}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:Configuration>
<DTS:Property DTS:Name="LastModifiedProductVersion">10.50.1600.1</DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">2052</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:Variable>
<DTS:Property DTS:Name="Expression"></DTS:Property>
<DTS:Property DTS:Name="EvaluateAsExpression">0</DTS:Property>
<DTS:Property DTS:Name="Namespace">User</DTS:Property>
<DTS:Property DTS:Name="ReadOnly">0</DTS:Property>
<DTS:Property DTS:Name="RaiseChangedEvent">0</DTS:Property>
<DTS:Property DTS:Name="IncludeInDebugDump">6789</DTS:Property><DTS:VariableValue DTS:DataType="3">0</DTS:VariableValue>
<DTS:Property DTS:Name="ObjectName">Counter</DTS:Property>
<DTS:Property DTS:Name="DTSID">{F18BE30C-5E7B-4E95-9DF0-02FA530307B1}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:Variable>
<DTS:Variable>
<DTS:Property DTS:Name="Expression"></DTS:Property>
<DTS:Property DTS:Name="EvaluateAsExpression">0</DTS:Property>
<DTS:Property DTS:Name="Namespace">User</DTS:Property>
<DTS:Property DTS:Name="ReadOnly">0</DTS:Property>
<DTS:Property DTS:Name="RaiseChangedEvent">0</DTS:Property>
<DTS:Property DTS:Name="IncludeInDebugDump">6789</DTS:Property><DTS:VariableValue DTS:DataType="7">1/11/2012</DTS:VariableValue>
<DTS:Property DTS:Name="ObjectName">StartTime</DTS:Property>
<DTS:Property DTS:Name="DTSID">{1A6BCC40-683E-4EF3-B164-5132B21AE16E}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:Variable>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Executable DTS:ExecutableType="Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" DTS:ThreadHint="0">
<DTS:Property DTS:Name="ExecutionLocation">0</DTS:Property>
<DTS:Property DTS:Name="ExecutionAddress"></DTS:Property>
<DTS:Property DTS:Name="TaskContact">Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1</DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">-1</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Property DTS:Name="ObjectName">是否有成功记录</DTS:Property>
<DTS:Property DTS:Name="DTSID">{46b29503-1dbc-4d65-838c-7a7c07ece802}</DTS:Property>
<DTS:Property DTS:Name="Description">执行 SQL 任务</DTS:Property>
<DTS:Property DTS:Name="CreationName">Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property><DTS:ObjectData><SQLTask:SqlTaskData SQLTask:Connection="{C66B6D20-0808-44B0-9B6A-CEFCBD06B0A2}" SQLTask:TimeOut="0" SQLTask:IsStoredProc="False" SQLTask:BypassPrepare="True" SQLTask:SqlStmtSourceType="DirectInput" SQLTask:SqlStatementSource="select count(*) from TaskRunLog where issuccess=1" SQLTask:CodePage="936" SQLTask:ResultType="ResultSetType_SingleRow" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask"><SQLTask:ResultBinding SQLTask:ResultName="0" SQLTask:DtsVariableName="User::Counter"/></SQLTask:SqlTaskData></DTS:ObjectData></DTS:Executable>
<DTS:Executable DTS:ExecutableType="Microsoft.SqlServer.Dts.Tasks.ScriptTask.ScriptTask, Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" DTS:ThreadHint="0">
<DTS:Property DTS:Name="ExecutionLocation">0</DTS:Property>
<DTS:Property DTS:Name="ExecutionAddress"></DTS:Property>
<DTS:Property DTS:Name="TaskContact"></DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">-1</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Property DTS:Name="ObjectName">脚本任务</DTS:Property>
<DTS:Property DTS:Name="DTSID">{887c9462-f42c-4347-87b3-0d296e9644d1}</DTS:Property>
<DTS:Property DTS:Name="Description">脚本任务</DTS:Property>
<DTS:Property DTS:Name="CreationName">Microsoft.SqlServer.Dts.Tasks.ScriptTask.ScriptTask, Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property><DTS:ObjectData><ScriptProject Name="ST_d1088276c6544ec7912f21301746801e" VSTAMajorVersion="2" VSTAMinorVersion="1" Language="CSharp" EntryPoint="Main" ReadOnlyVariables="" ReadWriteVariables=""><ProjectItem Name="\class2.cs">
<![CDATA[using System;
using System.Data;
using System.Xml;
using System.Data.SqlClient;
using System.Collections;

public sealed class SqlHelper
{
    #region private utility methods & constructors

    // Since this class provides only static methods, make the default constructor private to prevent 
    // instances from being created with "new SqlHelper()"
    private SqlHelper() { }

    /// <summary>
    /// This method is used to attach array of SqlParameters to a SqlCommand.
    /// 
    /// This method will assign a value of DbNull to any parameter with a direction of
    /// InputOutput and a value of null.  
    /// 
    /// This behavior will prevent default values from being used, but
    /// this will be the less common case than an intended pure output parameter (derived as InputOutput)
    /// where the user provided no input value.
    /// </summary>
    /// <param name="command">The command to which the parameters will be added</param>
    /// <param name="commandParameters">An array of SqlParameters to be added to command</param>
    private static void AttachParameters(SqlCommand command, SqlParameter[] commandParameters)
    {
        if (command == null) throw new ArgumentNullException("command");
        if (commandParameters != null)
        {
            foreach (SqlParameter p in commandParameters)
            {
                if (p != null)
                {
                    // Check for derived output value with no value assigned
                    if ((p.Direction == ParameterDirection.InputOutput ||
                        p.Direction == ParameterDirection.Input) &&
                        (p.Value == null))
                    {
                        p.Value = DBNull.Value;
                    }
                    command.Parameters.Add(p);
                }
            }
        }
    }

    /// <summary>
    /// This method assigns dataRow column values to an array of SqlParameters
    /// </summary>
    /// <param name="commandParameters">Array of SqlParameters to be assigned values</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
    private static void AssignParameterValues(SqlParameter[] commandParameters, DataRow dataRow)
    {
        if ((commandParameters == null) || (dataRow == null))
        {
            // Do nothing if we get no data
            return;
        }

        int i = 0;
        // Set the parameters values
        foreach (SqlParameter commandParameter in commandParameters)
        {
            // Check the parameter name
            if (commandParameter.ParameterName == null ||
                commandParameter.ParameterName.Length <= 1)
                throw new Exception(
                    string.Format(
                        "Please provide a valid parameter name on the parameter #{0}, the ParameterName property has the following value: '{1}'.",
                        i, commandParameter.ParameterName));
            if (dataRow.Table.Columns.IndexOf(commandParameter.ParameterName.Substring(1)) != -1)
                commandParameter.Value = dataRow[commandParameter.ParameterName.Substring(1)];
            i++;
        }
    }

    /// <summary>
    /// This method assigns an array of values to an array of SqlParameters
    /// </summary>
    /// <param name="commandParameters">Array of SqlParameters to be assigned values</param>
    /// <param name="parameterValues">Array of objects holding the values to be assigned</param>
    private static void AssignParameterValues(SqlParameter[] commandParameters, object[] parameterValues)
    {
        if ((commandParameters == null) || (parameterValues == null))
        {
            // Do nothing if we get no data
            return;
        }

        // We must have the same number of values as we pave parameters to put them in
        if (commandParameters.Length != parameterValues.Length)
        {
            throw new ArgumentException("Parameter count does not match Parameter Value count.");
        }

        // Iterate through the SqlParameters, assigning the values from the corresponding position in the 
        // value array
        for (int i = 0, j = commandParameters.Length; i < j; i++)
        {
            // If the current array value derives from IDbDataParameter, then assign its Value property
            if (parameterValues[i] is IDbDataParameter)
            {
                IDbDataParameter paramInstance = (IDbDataParameter)parameterValues[i];
                if (paramInstance.Value == null)
                {
                    commandParameters[i].Value = DBNull.Value;
                }
                else
                {
                    commandParameters[i].Value = paramInstance.Value;
                }
            }
            else if (parameterValues[i] == null)
            {
                commandParameters[i].Value = DBNull.Value;
            }
            else
            {
                commandParameters[i].Value = parameterValues[i];
            }
        }
    }

    /// <summary>
    /// This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
    /// to the provided command
    /// </summary>
    /// <param name="command">The SqlCommand to be prepared</param>
    /// <param name="connection">A valid SqlConnection, on which to execute this command</param>
    /// <param name="transaction">A valid SqlTransaction, or 'null'</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
    /// <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
    private static void PrepareCommand(SqlCommand command, SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters, out bool mustCloseConnection)
    {
        if (command == null) throw new ArgumentNullException("command");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        // If the provided connection is not open, we will open it
        if (connection.State != ConnectionState.Open)
        {
            mustCloseConnection = true;
            connection.Open();
        }
        else
        {
            mustCloseConnection = false;
        }

        // Associate the connection with the command
        command.Connection = connection;

        // Set the command text (stored procedure name or SQL statement)
        command.CommandText = commandText;

        // If we were provided a transaction, assign it
        if (transaction != null)
        {
            if (transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
            command.Transaction = transaction;
        }

        // Set the command type
        command.CommandType = commandType;

        // Attach the command parameters if they are provided
        if (commandParameters != null)
        {
            AttachParameters(command, commandParameters);
        }
        return;
    }

    #endregion private utility methods & constructors

    #region ExecuteNonQuery

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the database specified in 
    /// the connection string
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the database specified in the connection string 
    /// using the provided parameters
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteNonQuery(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored prcedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Finally, execute the command
        int retval = cmd.ExecuteNonQuery();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        if (mustCloseConnection)
            connection.Close();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Finally, execute the command
        int retval = cmd.ExecuteNonQuery();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteNonQuery

    #region ExecuteDataset

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteDataset(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter da = new SqlDataAdapter(cmd))
        {
            DataSet ds = new DataSet();

            // Fill the DataSet using default values for DataTable names, etc
            da.Fill(ds);

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            if (mustCloseConnection)
                connection.Close();

            // Return the dataset
            return ds;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter da = new SqlDataAdapter(cmd))
        {
            DataSet ds = new DataSet();

            // Fill the DataSet using default values for DataTable names, etc
            da.Fill(ds);

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            // Return the dataset
            return ds;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteDataset

    #region ExecuteReader

    /// <summary>
    /// This enum is used to indicate whether the connection was provided by the caller, or created by SqlHelper, so that
    /// we can set the appropriate CommandBehavior when calling ExecuteReader()
    /// </summary>
    private enum SqlConnectionOwnership
    {
        /// <summary>Connection is owned and managed by SqlHelper</summary>
        Internal,
        /// <summary>Connection is owned and managed by the caller</summary>
        External
    }

    /// <summary>
    /// Create and prepare a SqlCommand, and call ExecuteReader with the appropriate CommandBehavior.
    /// </summary>
    /// <remarks>
    /// If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
    /// 
    /// If the caller provided the connection, we want to leave it to them to manage.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection, on which to execute this command</param>
    /// <param name="transaction">A valid SqlTransaction, or 'null'</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
    /// <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by SqlHelper</param>
    /// <returns>SqlDataReader containing the results of the command</returns>
    private static SqlDataReader ExecuteReader(SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters, SqlConnectionOwnership connectionOwnership)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        bool mustCloseConnection = false;
        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        try
        {
            PrepareCommand(cmd, connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

            // Create a reader
            SqlDataReader dataReader;

            // Call ExecuteReader with the appropriate CommandBehavior
            if (connectionOwnership == SqlConnectionOwnership.External)
            {
                dataReader = cmd.ExecuteReader();
            }
            else
            {
                dataReader = cmd.ExecuteReader(CommandBehavior.CloseConnection);
            }

            // Detach the SqlParameters from the command object, so they can be used again.
            // HACK: There is a problem here, the output parameter values are fletched 
            // when the reader is closed, so if the parameters are detached from the command
            // then the SqlReader can磘 set its values. 
            // When this happen, the parameters can磘 be used again in other command.
            bool canClear = true;
            foreach (SqlParameter commandParameter in cmd.Parameters)
            {
                if (commandParameter.Direction != ParameterDirection.Input)
                    canClear = false;
            }

            if (canClear)
            {
                cmd.Parameters.Clear();
            }

            return dataReader;
        }
        catch
        {
            if (mustCloseConnection)
                connection.Close();
            throw;
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        SqlConnection connection = null;
        try
        {
            connection = new SqlConnection(connectionString);
            connection.Open();

            // Call the private overload that takes an internally owned connection in place of the connection string
            return ExecuteReader(connection, null, commandType, commandText, commandParameters, SqlConnectionOwnership.Internal);
        }
        catch
        {
            // If we fail to return the SqlDatReader, we need to close the connection ourselves
            if (connection != null) connection.Close();
            throw;
        }

    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        // Pass through the call to the private overload using a null transaction value and an externally owned connection
        return ExecuteReader(connection, (SqlTransaction)null, commandType, commandText, commandParameters, SqlConnectionOwnership.External);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///   SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Pass through to private overload, indicating that the connection is owned by the caller
        return ExecuteReader(transaction.Connection, transaction, commandType, commandText, commandParameters, SqlConnectionOwnership.External);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteReader

    #region ExecuteScalar

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteScalar(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();

        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Execute the command & return the results
        object retval = cmd.ExecuteScalar();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();

        if (mustCloseConnection)
            connection.Close();

        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Execute the command & return the results
        object retval = cmd.ExecuteScalar();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // PPull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteScalar

    #region ExecuteXmlReader
    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteXmlReader(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        bool mustCloseConnection = false;
        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        try
        {
            PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

            // Create the DataAdapter & DataSet
            XmlReader retval = cmd.ExecuteXmlReader();

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            return retval;
        }
        catch
        {
            if (mustCloseConnection)
                connection.Close();
            throw;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure using "FOR XML AUTO"</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteXmlReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteXmlReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteXmlReader(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        XmlReader retval = cmd.ExecuteXmlReader();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteXmlReader

    #region FillDataset
    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)</param>
    public static void FillDataset(string connectionString, CommandType commandType, string commandText, DataSet dataSet, string[] tableNames)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, commandType, commandText, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    public static void FillDataset(string connectionString, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, commandType, commandText, dataSet, tableNames, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, 24);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>    
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(string connectionString, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, spName, dataSet, tableNames, parameterValues);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>    
    public static void FillDataset(SqlConnection connection, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames)
    {
        FillDataset(connection, commandType, commandText, dataSet, tableNames, null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    public static void FillDataset(SqlConnection connection, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        FillDataset(connection, null, commandType, commandText, dataSet, tableNames, commandParameters);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(conn, "GetOrders", ds, new string[] {"orders"}, 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(SqlConnection connection, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            FillDataset(connection, CommandType.StoredProcedure, spName, dataSet, tableNames, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            FillDataset(connection, CommandType.StoredProcedure, spName, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    public static void FillDataset(SqlTransaction transaction, CommandType commandType,
        string commandText,
        DataSet dataSet, string[] tableNames)
    {
        FillDataset(transaction, commandType, commandText, dataSet, tableNames, null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    public static void FillDataset(SqlTransaction transaction, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        FillDataset(transaction.Connection, transaction, commandType, commandText, dataSet, tableNames, commandParameters);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(trans, "GetOrders", ds, new string[]{"orders"}, 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(SqlTransaction transaction, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            FillDataset(transaction, CommandType.StoredProcedure, spName, dataSet, tableNames, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            FillDataset(transaction, CommandType.StoredProcedure, spName, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Private helper method that execute a SqlCommand (that returns a resultset) against the specified SqlTransaction and SqlConnection
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    private static void FillDataset(SqlConnection connection, SqlTransaction transaction, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (dataSet == null) throw new ArgumentNullException("dataSet");

        // Create a command and prepare it for execution
        SqlCommand command = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(command, connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter dataAdapter = new SqlDataAdapter(command))
        {

            // Add the table mappings specified by the user
            if (tableNames != null && tableNames.Length > 0)
            {
                string tableName = "Table";
                for (int index = 0; index < tableNames.Length; index++)
                {
                    if (tableNames[index] == null || tableNames[index].Length == 0) throw new ArgumentException("The tableNames parameter must contain a list of tables, a value was provided as null or empty string.", "tableNames");
                    dataAdapter.TableMappings.Add(tableName, tableNames[index]);
                    tableName += (index + 1).ToString();
                }
            }

            // Fill the DataSet using default values for DataTable names, etc
            dataAdapter.Fill(dataSet);

            // Detach the SqlParameters from the command object, so they can be used again
            command.Parameters.Clear();
        }

        if (mustCloseConnection)
            connection.Close();
    }
    #endregion

    #region UpdateDataset
    /// <summary>
    /// Executes the respective command for each inserted, updated, or deleted row in the DataSet.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  UpdateDataset(conn, insertCommand, deleteCommand, updateCommand, dataSet, "Order");
    /// </remarks>
    /// <param name="insertCommand">A valid transact-SQL statement or stored procedure to insert new records into the data source</param>
    /// <param name="deleteCommand">A valid transact-SQL statement or stored procedure to delete records from the data source</param>
    /// <param name="updateCommand">A valid transact-SQL statement or stored procedure used to update records in the data source</param>
    /// <param name="dataSet">The DataSet used to update the data source</param>
    /// <param name="tableName">The DataTable used to update the data source.</param>
    public static void UpdateDataset(SqlCommand insertCommand, SqlCommand deleteCommand, SqlCommand updateCommand, DataSet dataSet, string tableName)
    {
        if (insertCommand == null) throw new ArgumentNullException("insertCommand");
        if (deleteCommand == null) throw new ArgumentNullException("deleteCommand");
        if (updateCommand == null) throw new ArgumentNullException("updateCommand");
        if (tableName == null || tableName.Length == 0) throw new ArgumentNullException("tableName");

        // Create a SqlDataAdapter, and dispose of it after we are done
        using (SqlDataAdapter dataAdapter = new SqlDataAdapter())
        {
            // Set the data adapter commands
            dataAdapter.UpdateCommand = updateCommand;
            dataAdapter.InsertCommand = insertCommand;
            dataAdapter.DeleteCommand = deleteCommand;

            // Update the dataset changes in the data source
            dataAdapter.Update(dataSet, tableName);

            // Commit all the changes made to the DataSet
            dataSet.AcceptChanges();
        }
    }
    #endregion

    #region CreateCommand
    /// <summary>
    /// Simplify the creation of a Sql command object by allowing
    /// a stored procedure and optional parameters to be provided
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlCommand command = CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
    /// <returns>A valid SqlCommand object</returns>
    public static SqlCommand CreateCommand(SqlConnection connection, string spName, params string[] sourceColumns)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // Create a SqlCommand
        SqlCommand cmd = new SqlCommand(spName, connection);
        cmd.CommandType = CommandType.StoredProcedure;

        // If we receive parameter values, we need to figure out where they go
        if ((sourceColumns != null) && (sourceColumns.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided source columns to these parameters based on parameter order
            for (int index = 0; index < sourceColumns.Length; index++)
                commandParameters[index].SourceColumn = sourceColumns[index];

            // Attach the discovered parameters to the SqlCommand object
            AttachParameters(cmd, commandParameters);
        }

        return cmd;
    }
    #endregion

    #region ExecuteNonQueryTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.  
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified
    /// SqlTransaction using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // Sf the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteDatasetTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(string connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        //If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the store procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion

    #region ExecuteReaderTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(connectionString, CommandType.StoredProcedure, spName);
        }
    }


    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteScalarTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlTransaction
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteXmlReaderTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReaderTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteXmlReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteXmlReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReaderTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion


    #region 实用方法
    public static string SecLike(string like, bool preMatch, bool lastMatch)
    {
        if (!string.IsNullOrEmpty(like))
        {
            like = like.Replace("[", "[[]").Replace("%", "[%]");
        }
        else
        {
            like = "";
        }
        if (preMatch) like = "%" + like;
        like.TrimEnd('%');
        if (lastMatch) like += "%";
        return like;
    }

    public static DateTime? SecDate(DateTime date, bool nullable)
    {
        if (date < DateTime.Parse("1/1/1753 12:00:00 AM ")) return nullable ? null : new DateTime?(DateTime.Parse("1/1/1753 12:00:00 AM "));
        if (date > DateTime.Parse("12/31/9999 11:59:59 PM")) return nullable ? null : new DateTime?(DateTime.Parse("12/31/9999 11:59:59 PM"));
        return new DateTime?(date);
    }

    public static int? SecInt(int value, bool nullable)
    {
        if (value < -2147483648) return nullable ? null : new int?((-2147483648));
        if (value > 2147483647) return nullable ? null : new int?(2147483647);
        return new int?(value);
    }

    public static int SecIntMax(int? value)
    {
        if (value == null || value == 0)
        {
            return 2147483647;
        }
        else return value.Value;
    }

    public static int SecIntMin(int? value)
    {
        if (value == null)
        {
            return 0;
        }
        else return value.Value;
    }
    #endregion

}

/// <summary>
/// SqlHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
/// ability to discover parameters for stored procedures at run-time.
/// </summary>
public sealed class SqlHelperParameterCache
{
    #region private methods, variables, and constructors

    //Since this class provides only static methods, make the default constructor private to prevent 
    //instances from being created with "new SqlHelperParameterCache()"
    private SqlHelperParameterCache() { }

    private static Hashtable paramCache = Hashtable.Synchronized(new Hashtable());

    /// <summary>
    /// Resolve at run time the appropriate set of SqlParameters for a stored procedure
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
    /// <returns>The parameter array discovered.</returns>
    private static SqlParameter[] DiscoverSpParameterSet(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        SqlCommand cmd = new SqlCommand(spName, connection);
        cmd.CommandType = CommandType.StoredProcedure;

        connection.Open();
        SqlCommandBuilder.DeriveParameters(cmd);
        connection.Close();

        if (!includeReturnValueParameter)
        {
            cmd.Parameters.RemoveAt(0);
        }

        SqlParameter[] discoveredParameters = new SqlParameter[cmd.Parameters.Count];

        cmd.Parameters.CopyTo(discoveredParameters, 0);

        // Init the parameters with a DBNull value
        foreach (SqlParameter discoveredParameter in discoveredParameters)
        {
            discoveredParameter.Value = DBNull.Value;
        }
        return discoveredParameters;
    }

    /// <summary>
    /// Deep copy of cached SqlParameter array
    /// </summary>
    /// <param name="originalParameters"></param>
    /// <returns></returns>
    private static SqlParameter[] CloneParameters(SqlParameter[] originalParameters)
    {
        SqlParameter[] clonedParameters = new SqlParameter[originalParameters.Length];

        for (int i = 0, j = originalParameters.Length; i < j; i++)
        {
            clonedParameters[i] = (SqlParameter)((ICloneable)originalParameters[i]).Clone();
        }

        return clonedParameters;
    }

    #endregion private methods, variables, and constructors

    #region caching functions

    /// <summary>
    /// Add parameter array to the cache
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters to be cached</param>
    public static void CacheParameterSet(string connectionString, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        string hashKey = connectionString + ":" + commandText;

        paramCache[hashKey] = commandParameters;
    }

    /// <summary>
    /// Retrieve a parameter array from the cache
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An array of SqlParamters</returns>
    public static SqlParameter[] GetCachedParameterSet(string connectionString, string commandText)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        string hashKey = connectionString + ":" + commandText;

        SqlParameter[] cachedParameters = paramCache[hashKey] as SqlParameter[];
        if (cachedParameters == null)
        {
            return null;
        }
        else
        {
            return CloneParameters(cachedParameters);
        }
    }

    #endregion caching functions

    #region Parameter Discovery Functions

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <returns>An array of SqlParameters</returns>
    public static SqlParameter[] GetSpParameterSet(string connectionString, string spName)
    {
        return GetSpParameterSet(connectionString, spName, false);
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    public static SqlParameter[] GetSpParameterSet(string connectionString, string spName, bool includeReturnValueParameter)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            return GetSpParameterSetInternal(connection, spName, includeReturnValueParameter);
        }
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <returns>An array of SqlParameters</returns>
    internal static SqlParameter[] GetSpParameterSet(SqlConnection connection, string spName)
    {
        return GetSpParameterSet(connection, spName, false);
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    internal static SqlParameter[] GetSpParameterSet(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        using (SqlConnection clonedConnection = (SqlConnection)((ICloneable)connection).Clone())
        {
            return GetSpParameterSetInternal(clonedConnection, spName, includeReturnValueParameter);
        }
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    private static SqlParameter[] GetSpParameterSetInternal(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        string hashKey = connection.ConnectionString + ":" + spName + (includeReturnValueParameter ? ":include ReturnValue Parameter" : "");

        SqlParameter[] cachedParameters;

        cachedParameters = paramCache[hashKey] as SqlParameter[];
        if (cachedParameters == null)
        {
            SqlParameter[] spParameters = DiscoverSpParameterSet(connection, spName, includeReturnValueParameter);
            paramCache[hashKey] = spParameters;
            cachedParameters = spParameters;
        }

        return CloneParameters(cachedParameters);
    }

    #endregion Parameter Discovery Functions

}]]></ProjectItem><ProjectItem Name="\properties\resources.resx">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem><ProjectItem Name="\properties\settings.designer.cs">
<![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Settings.get_Default():ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Sett" +
    "ings")]

namespace ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties
{


    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem><ProjectItem Name="\properties\settings.settings">
<![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem><ProjectItem Name="\st_d1088276c6544ec7912f21301746801e.csproj">
<![CDATA[<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"><!-- This section defines project-level properties.

       Configuration - Specifies whether the default configuration is Release or Debug.
       Platform - Specifies what CPU the output of this project can run on.
       OutputType - Must be "Library" for VSTA.
       NoStandardLibraries - Set to "false" for VSTA.
       RootNamespace - In C#, this specifies the namespace given to new files.
                       In Visual Basic, all objects are wrapped in this namespace at runtime.
       AssemblyName - Name of the output assembly.
  --><PropertyGroup><ProjectTypeGuids>{A860303F-1F3F-4691-B57E-529FC101A107};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids><Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration><Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform><OutputType>Library</OutputType><NoStandardLibraries>false</NoStandardLibraries><RootNamespace>ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj</RootNamespace><AssemblyName>st_d1088276c6544ec7912f21301746801e</AssemblyName><ProjectGuid>{6803E4D3-CD6B-4DDA-B91A-A713C13E3AB2}</ProjectGuid><TargetFrameworkVersion>v3.5</TargetFrameworkVersion></PropertyGroup><!-- This section defines properties that are set when the "Debug" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  --><PropertyGroup Condition=" '$(Configuration)' == 'Debug' "><DebugSymbols>true</DebugSymbols><Optimize>false</Optimize><OutputPath>.\bin\Debug\</OutputPath><EnableUnmanagedDebugging>false</EnableUnmanagedDebugging><DefineConstants>DEBUG;TRACE</DefineConstants><WarningLevel>4</WarningLevel></PropertyGroup><!-- This section defines properties that are set when the "Release" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  --><PropertyGroup Condition=" '$(Configuration)' == 'Release' "><DebugSymbols>false</DebugSymbols><Optimize>true</Optimize><OutputPath>.\bin\Release\</OutputPath><EnableUnmanagedDebugging>false</EnableUnmanagedDebugging><DefineConstants>TRACE</DefineConstants><WarningLevel>4</WarningLevel></PropertyGroup><!-- This section enables pre- and post-build steps. However,
       it is recommended that MSBuild tasks be used instead of these properties.
  --><PropertyGroup><PreBuildEvent></PreBuildEvent><PostBuildEvent></PostBuildEvent></PropertyGroup><!-- This sections specifies references for the project. --><ItemGroup><Reference Include="MongoDB.Bson, Version=1.3.1.4349, Culture=neutral, PublicKeyToken=f686731cfb9cc103, processorArchitecture=MSIL"><SpecificVersion>False</SpecificVersion><HintPath>D:\work\Tarot\Tarot\packages\CSharpDriver-1.3.1.4349\MongoDB.Bson.dll</HintPath></Reference><Reference Include="MongoDB.Driver, Version=1.3.1.4349, Culture=neutral, PublicKeyToken=f686731cfb9cc103, processorArchitecture=MSIL"><SpecificVersion>False</SpecificVersion><HintPath>D:\work\Tarot\Tarot\packages\CSharpDriver-1.3.1.4349\MongoDB.Driver.dll</HintPath></Reference><Reference Include="System" /><Reference Include="System.AddIn, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL" /><Reference Include="System.Core"><RequiredTargetFramework>3.5</RequiredTargetFramework></Reference><Reference Include="System.Data" /><Reference Include="System.Windows.Forms" /><Reference Include="System.Xml" /><Reference Include="Microsoft.SqlServer.ManagedDTS, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" /><Reference Include="Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" /></ItemGroup><!-- This section defines the user source files that are part of the
       project.

       Compile - Specifies a source file to compile.
       EmbeddedResource - Specifies a .resx file for embedded resources.
       None - Specifies a file that is not to be passed to the compiler (for instance,
              a text file or XML file).
       AppDesigner - Specifies the directory where the application properties files can
                     be found.
  --><ItemGroup><AppDesigner Include="Properties\" /><Compile Include="Class1.cs" /><Compile Include="Class2.cs" /><Compile Include="Model.cs" /><Compile Include="Properties\AssemblyInfo.cs"><SubType>Code</SubType></Compile><EmbeddedResource Include="Properties\Resources.resx"><Generator>ResXFileCodeGenerator</Generator><LastGenOutput>Resources.Designer.cs</LastGenOutput></EmbeddedResource><Compile Include="Properties\Resources.Designer.cs"><AutoGen>True</AutoGen><DependentUpon>Resources.resx</DependentUpon></Compile><None Include="Properties\Settings.settings"><Generator>SettingsSingleFileGenerator</Generator><LastGenOutput>Settings.Designer.cs</LastGenOutput></None><Compile Include="Properties\Settings.Designer.cs"><AutoGen>True</AutoGen><DependentUpon>Settings.settings</DependentUpon></Compile><Compile Include="ScriptMain.cs"><SubType>Code</SubType></Compile><!-- Include the default configuration information and metadata files for the add-in.
         These files are copied to the build output directory when the project is
         built, and the path to the configuration file is passed to add-in on the command
         line when debugging.
    --></ItemGroup><!-- Include the build rules for a C# project.--><Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" /><!-- This section defines VSTA properties that describe the host-changable project properties. --><ProjectExtensions><VisualStudio><FlavorProperties GUID="{A860303F-1F3F-4691-B57E-529FC101A107}"><ProjectProperties HostName="VSTAHostName" HostPackage="{C1B21C64-9E6F-4923-A89D-9F958503C1CE}" ApplicationType="usd" Language="cs" TemplatesPath="" DebugInfoExeName="#HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\InstallDir#\devenv.exe" /><Host Name="SSIS_ScriptTask" /><ProjectClient><HostIdentifier>SSIS_ScriptTask</HostIdentifier></ProjectClient></FlavorProperties></VisualStudio></ProjectExtensions></Project>]]></ProjectItem><ProjectItem Name="\properties\assemblyinfo.cs">
<![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj")]
[assembly: AssemblyCopyright("Copyright @  2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem><ProjectItem Name="\model.cs">
<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MongoDB.Bson;


public class M_Post
{
    //[MongoID]
    public ObjectId _id { get; set; }
    public string _idForString { get; set; }

    private DateTime _PostTime;
    public DateTime PostTime { get { return _PostTime.ToLocalTime(); } set { _PostTime = value; } }
    private DateTime _LastModifyTime;
    public DateTime LastModifyTime { get { return _LastModifyTime.ToLocalTime(); } set { _LastModifyTime = value; } }

    public string Title { get; set; }
    /// <summary>
    /// 帖子内容
    /// </summary>
    public string Content { get; set; }

    public int ReplyCount { get; set; }
    /// <summary>
    /// 人气
    /// </summary>
    public int PopularityCount { get; set; }
    /// <summary>
    /// 审核状态
    /// </summary>
    public bool AuditState { get; set; }

    /// <summary>
    /// 1塔罗贴, 2 普通帖
    /// </summary>
    public int PostType { get; set; }
    /// <summary>
    /// 帖子状态
    /// </summary>
    public int PostState { get; set; }
    public string IP { get; set; }

    /// <summary>
    /// 用作"顶", 或者"标记"
    /// </summary>
    public int Mark { get; set; }
    public int Down { get; set; }

    /// <summary>
    /// 总参与人数. 回帖+顶+踩的总数
    /// </summary>
    public int AllTakePartIn { get; set; }
    /// <summary>
    /// 自定义标签
    /// </summary>
    public CustomerTag[] CustomerTags { get; set; }

    /// <summary>
    /// 塔罗牌
    /// </summary>
    public CardFormationInfo CardFormationInfo { get; set; }
    /// <summary>
    /// mongodb 用户信息
    /// </summary>
    public M_User m_User { get; set; }
}

public class M_User
{
    public int UserID { get; set; }
    public string NicName { get; set; }
    private string _AvatarURL;
    /// <summary>
    /// 头像
    /// </summary>
    public string AvatarURL
    {
        get
        {
            return _AvatarURL;
        }
        set { _AvatarURL = value; }
    }
}

public class CardFormationInfo
{
    public string CardFormationUrl { get; set; }
    public string CardFormationName { get; set; }
    public string CardFormationID { get; set; }
    public int W { get; set; }
    public int H { get; set; }
    public CardInfo[] CardInfos { get; set; }
}
public class CardInfo
{
    public string CardName { get; set; }

    public bool IsHandstand { get; set; }

    public string ImgUrl { get; set; }

    public bool IsPointCard { get; set; }

    public int X { get; set; }

    public int Y { get; set; }

    public int SortIndex { get; set; }

    public string Describe { get; set; }

    public int W { get; set; }

    public int H { get; set; }
}

public class Comment
{
    public ObjectId _id { get; set; }
    /// <summary>
    /// 冗余字段
    /// </summary>
    public string _idForString { get; set; }
    /// <summary>
    /// 冗余字段
    /// </summary>
    public int _Index { get; set; }
    /// <summary>
    /// 引用的外键id.
    /// </summary>
    public string FKid { get; set; }

    private string _Content;
    /// <summary>
    /// 回帖类型, 见枚举
    /// </summary>
    public int FKType { get; set; }

    public string Content
    {
        get
        {
            return _Content;
        }
        set { _Content = value; }
    }

    /// <summary>
    /// 子评论
    /// </summary>
    public Comment[] Children { get; set; }

    /// <summary>
    /// 帖子状态
    /// </summary>
    public int PostState { get; set; }
    public string IP { get; set; }
    public DateTime PostTime { get; set; }

    public M_User m_User { get; set; }

    /// <summary>
    /// 评论级别. 现在就顶级评论和子级评论
    /// </summary>
    public int CommentLevel { get; set; }
}

public class CustomerTag
{
    public ObjectId _id { get; set; }
    public string TagName { get; set; }
    /// <summary>
    /// 人气
    /// </summary>
    public int PopularityCount { get; set; }
    public DateTime CreateTime { get; set; }
    public DateTime LastModifyTime { get; set; }
}]]></ProjectItem><ProjectItem Name="\scriptmain.cs">
<![CDATA[/*
   Microsoft SQL Server Integration Services Script Task
   Write scripts using Microsoft Visual C# 2008.
   The ScriptMain is the entry point class of the script.
*/

using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using MongoDB.Driver.Builders;

namespace ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj
{
    [System.AddIn.AddIn("ScriptMain", Version = "1.0", Publisher = "", Description = "")]
    public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
    {

        #region VSTA generated code
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

        /*
		The execution engine calls this method when the task executes.
		To access the object model, use the Dts property. Connections, variables, events,
		and logging features are available as members of the Dts property as shown in the following examples.

		To reference a variable, call Dts.Variables["MyCaseSensitiveVariableName"].Value;
		To post a log entry, call Dts.Log("This is my log text", 999, null);
		To fire an event, call Dts.Events.FireInformation(99, "test", "hit the help message", "", 0, true);

		To use the connections collection use something like the following:
		ConnectionManager cm = Dts.Connections.Add("OLEDB");
		cm.ConnectionString = "Data Source=localhost;Initial Catalog=AdventureWorks;Provider=SQLNCLI10;Integrated Security=SSPI;Auto Translate=False;";

		Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
		
		To open Help, press F1.
	*/

        public void Main()
        {
            MongoDBHelper.DeleteAll("Posts");
            MongoDBHelper.DeleteAll("Comments");

            MongoDBHelper.UpdateAll<CustomerTag>("CustomerTag", Query.Null, Update.Set("PopularityCount", 0));

            string conn = "Data Source=.;Initial Catalog=Tarot;Persist Security Info=True;User ID=sa;Password=sa1234;timeout=240";
            SqlHelper.ExecuteNonQuery(conn, CommandType.Text, "update CardFormation set Popularity=0");

            // TODO: Add your code here
            //Dts.TaskResult = (int)ScriptResults.Success;

           
        }
    }
}]]></ProjectItem><ProjectItem Name="\properties\resources.designer.cs">
<![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem><ProjectItem Name="\class1.cs">
<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MongoDB.Driver;
using MongoDB.Bson;
using MongoDB.Driver.Builders;

public class PagerInfo
    {
        int _Page = 1;//当前页
        int _PageSize = 10;
        public int Page { get { return _Page; } set { _Page = value; } }
        public int PageSize { get { return _PageSize; } set { _PageSize = value; } }
    }

    public sealed class MongoDBHelper
    //public sealed class MongoDBHelper<T>
    //where T :class
    {

        public static readonly string connectionString_Default = "Server=127.0.0.1"; // System.Configuration.ConfigurationManager.AppSettings["ConnectionString_mongoDB"];
        public static readonly string database_Default = "Tarot";

        #region 新增

        public static SafeModeResult InsertOne<T>(string collectionName, T entity)
        {
            return MongoDBHelper.InsertOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entity);
        }

        public static SafeModeResult InsertOne<T>(string connectionString, string databaseName, string collectionName, T entity)
        {
            SafeModeResult result = new SafeModeResult();

            if (null == entity)
            {
                return null;
            }

            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);



            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
                result = myCollection.Insert(entity);
            }

            return result;
        }

        public static IEnumerable<SafeModeResult> InsertAll<T>(string collectionName, IEnumerable<T> entitys)
        {
            return MongoDBHelper.InsertAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entitys);
        }

        public static IEnumerable<SafeModeResult> InsertAll<T>(string connectionString, string databaseName, string collectionName, IEnumerable<T> entitys)
        {
            IEnumerable<SafeModeResult> result = null;

            if (null == entitys)
            {
                return null;
            }

            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);



            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
                result = myCollection.InsertBatch(entitys);
            }

            return result;
        }

        #endregion


        #region 修改

        public static SafeModeResult UpdateOne<T>(string collectionName, T entity)
        {
            return MongoDBHelper.UpdateOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entity);
        }

        public static SafeModeResult UpdateOne<T>(string connectionString, string databaseName, string collectionName, T entity)
        {
            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            SafeModeResult result;

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                result = myCollection.Save(entity);

            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="update">更新设置。调用示例：Update.Set("Title", "yanc") 或者 Update.Set("Title", "yanc").Set("Author", "yanc2") 等等</param>
        /// <returns></returns>
        public static SafeModeResult UpdateAll<T>(string collectionName, IMongoQuery query, IMongoUpdate update)
        {
            return MongoDBHelper.UpdateAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, update);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="update">更新设置。调用示例：Update.Set("Title", "yanc") 或者 Update.Set("Title", "yanc").Set("Author", "yanc2") 等等</param>
        /// <returns></returns>
        public static SafeModeResult UpdateAll<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query, IMongoUpdate update)
        {
            SafeModeResult result;

            if (null == query || null == update)
            {
                return null;
            }


            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
                
                result = myCollection.Update(query, update, UpdateFlags.Multi);
            }

            return result;
        }

        #endregion


        #region 删除

        public static SafeModeResult Delete(string collectionName, string _id)
        {
            return MongoDBHelper.Delete(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, _id);
        }

        public static SafeModeResult Delete(string connectionString, string databaseName, string collectionName, string _id)
        {
            SafeModeResult result;
            ObjectId id;
            if (!ObjectId.TryParse(_id, out id))
            {
                return null;
            }



            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);



            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                result = myCollection.Remove(Query.EQ("_id", id));
            }

            return result;

        }

        public static SafeModeResult DeleteAll(string collectionName)
        {
            return MongoDBHelper.DeleteAll(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <returns></returns>
        public static SafeModeResult DeleteAll(string collectionName, IMongoQuery query)
        {
            return MongoDBHelper.DeleteAll(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <returns></returns>
        public static SafeModeResult DeleteAll(string connectionString, string databaseName, string collectionName, IMongoQuery query)
        {
            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            SafeModeResult result;

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                if (null == query)
                {
                    result = myCollection.RemoveAll();
                }
                else
                {
                    result = myCollection.Remove(query);
                }
            }

            return result;

        }

        #endregion


        #region 获取单条信息

        public static T GetOne<T>(string collectionName, string _id)
        {
            return MongoDBHelper.GetOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, _id);
        }

        public static T GetOne<T>(string connectionString, string databaseName, string collectionName, string _id)
        {
            T result = default(T);
            ObjectId id;
            if (!ObjectId.TryParse(_id, out id))
            {
                return default(T);
            }

            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);



            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);


                result = myCollection.FindOneAs<T>(Query.EQ("_id", id));
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <returns></returns>
        public static T GetOne<T>(string collectionName, IMongoQuery query)
        {
            return GetOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <returns></returns>
        public static T GetOne<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query)
        {
            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            T result = default(T);

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                if (null == query)
                {
                    result = myCollection.FindOneAs<T>();
                }
                else
                {
                    result = myCollection.FindOneAs<T>(query);
                }
            }

            return result;
        }
        public static bool Exists(string collectionName, IMongoQuery query)
        {
            return Count(collectionName, query) > 0;
        }

        public static int Count(string collectionName, IMongoQuery query) {
            MongoServer server = MongoServer.Create(connectionString_Default);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(database_Default);

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                return (int)myCollection.Count(query);
            }
        }
        #endregion


        #region 获取多个

        public static List<T> GetAll<T>(string collectionName, IMongoQuery query)
        {
            if (query == null) query = Query.Null;
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
        }

        /// <summary>
        /// 如果不清楚具体的数量，一般不要用这个函数。
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query)
        {
            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            List<T> result = new List<T>();

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                foreach (T entity in myCollection.FindAs<T>(query))
                {
                    result.Add(entity);
                }
            }

            return result;
        }

        public static List<T> GetAll<T>(string collectionName, int count)
        {
            return MongoDBHelper.GetAll<T>(collectionName, count, null, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="count"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, int count, IMongoQuery query)
        {
            return MongoDBHelper.GetAll<T>(collectionName, count, query, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="count"></param>
        /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, int count, IMongoSortBy sortBy)
        {
            return MongoDBHelper.GetAll<T>(collectionName, count, null, sortBy);
        }

        /// <summary>

        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="count"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
        /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, int count, IMongoQuery query, IMongoSortBy sortBy, params string[] fields)
        {
            PagerInfo pagerInfo = new PagerInfo();
            pagerInfo.Page = 1;
            pagerInfo.PageSize = count;
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy, fields);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="pagerInfo"></param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo)
        {
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="pagerInfo"></param>
        /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy)
        {
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="pagerInfo"></param>
        /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, params string[] fields)
        {
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, null, fields);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="pagerInfo"></param>
        /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
        /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy, params string[] fields)
        {
            return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy, fields);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="collectionName"></param>
        /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
        /// <param name="pagerInfo"></param>
        /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
        /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
        /// <returns></returns>
        public static List<T> GetAll<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy, params string[] fields)
        {
            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);

            List<T> result = new List<T>();

            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

                MongoCursor<T> myCursor;

                if (null == query)
                {
                    myCursor = myCollection.FindAllAs<T>();
                }
                else
                {
                    myCursor = myCollection.FindAs<T>(query);
                }

                if (null != sortBy)
                {
                    myCursor.SetSortOrder(sortBy);
                }

                if (null != fields)
                {
                    myCursor.SetFields(fields);
                }

                foreach (T entity in myCursor.SetSkip((pagerInfo.Page - 1) * pagerInfo.PageSize).SetLimit(pagerInfo.PageSize))//.SetSkip(100).SetLimit(10)是指读取第一百条后的10条数据。
                {
                    result.Add(entity);
                }


            }

            return result;
        }

        #endregion


        #region 索引
        public static void CreateIndex(string collectionName, params string[] keyNames)
        {
            MongoDBHelper.CreateIndex(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, keyNames);
        }

        public static void CreateIndex(string connectionString, string databaseName, string collectionName, params string[] keyNames)
        {
            SafeModeResult result = new SafeModeResult();

            if (null == keyNames)
            {
                return;
            }

            MongoServer server = MongoServer.Create(connectionString);

            //获取数据库或者创建数据库（不存在的话）。
            MongoDatabase database = server.GetDatabase(databaseName);



            using (server.RequestStart(database))//开始连接数据库。
            {
                MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
                if (!myCollection.IndexExists(keyNames))
                {
                    myCollection.EnsureIndex(keyNames);
                }
            }

        }
        #endregion




    }]]></ProjectItem><BinaryItem Name="\bin\release\st_71cfb311a18d4b5f9086d717d0fa4c6b.csproj.dll">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
b3wAAAreCgksBglvLAAACtwqAAABEAAAAgAhABo7AAoAAAAAVnKqBABwgD0AAARyzAQAcIA+AAAE
Kh4CKBAAAAoqHgIoEAAACioAABMwAwAtAAAAKAAAEX4/AAAELSBy2AQAcNANAAACKH4AAApvfwAA
CnOAAAAKCgaAPwAABH4/AAAEKhp+QAAABCoeAoBAAAAEKhMwBABKAAAAGQAAEXJYBQBwKNwAAAYm
cmQFAHAo3AAABiZydgUAcChwAAAKco4FAHAWKIMAAAoohAAACigSAAArJnKuBQBwCgYXcnsGAHAo
eAAABiYqHgIohQAACioafkQAAAQqLnP7AAAGgEQAAAQqHgIohgAACioAAAC0AAAAzsrvvgEAAACR
AAAAbFN5c3RlbS5SZXNvdXJjZXMuUmVzb3VyY2VSZWFkZXIsIG1zY29ybGliLCBWZXJzaW9uPTIu
MC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OSNT
eXN0ZW0uUmVzb3VyY2VzLlJ1bnRpbWVSZXNvdXJjZVNldAIAAAAAAAAAAAAAAFBBRFBBRFC0AAAA
QlNKQgEAAQAAAAAADAAAAHYyLjAuNTA3MjcAAAAABQBsAAAA5CsAACN+AABQLAAAYBsAACNTdHJp
bmdzAAAAALBHAADIBgAAI1VTAHhOAAAQAAAAI0dVSUQAAACITgAAGAsAACNCbG9iAAAAAAAAAAIA
AAFXHaIJCQ8AAAD6ATMAFgAAAQAAAFcAAAAQAAAARAAAAPwAAADHAQAAhgAAAAQAAADPAAAAKAAA
AAkAAAA7AAAAdAAAAAcAAAABAAAACAAAAAEAAAACAAAAFwAAABIAAAAAAAoAAQAAAAAABgBkAV0B
BgBrAV0BCgC4AY8BDgDpAdQBEgAOAgECBgBJAl0BFgB7DGUMFgCGDGUMFgCkDFkMFgDCDGUMFgDQ
DGUMFgDfDFkMFgAKDVkMFgAhDWUMGgBWDUsNBgAkDl0BBgB/DmwOHgCSD4MPBgDID60PHgDqD4MP
HgD2D4MPBgAyEK0PHgBAEIMPBgBqEFkQBgCbEIYQBgC+EZ8RBgDcEV0BBgAmExQTBgA9ExQTBgBa
ExQTBgB5ExQTBgCSExQTBgCrExQTBgDGExQTBgDhExQTBgD6ExQTBgAzFBMUBgBTFBMUBgBxFBMU
BgCYFF0BFgDBFK4UFgDNFFkMBgD4FF0BFgAPFWUMBgBLFV0BBgBdFV0BBgBqFV0BFgB0FVkMFgCI
FVkMBgDEFV0BFgDWFVkMFgDnFVkMFgD2Fa4UFgADFlkMFgAxFq4UBgB6Fl0BFgCOFq4UFgCwFmUM
FgC/Fq4UFgDQFlkMBgDgFmwOFgAPF64UFgA8F64UFgCTF64UBgDrF10BFgA4GGUMBgB1GF0BHgC4
GIMPHgDLGIMPHgDyGIMPEgASGQECHgAfGYMPHgBHGYMPEgBcGQECHgCKGXIZHgCQGXIZHgDFGYMP
BgDaGa0PBgBFGjIaBgBiGl0BBgBnGl0BBgCLGhQTDgC3GqEaDgDQGqEaIgDyGuUaHgChF3IZHgAB
G3IZAAAAAAEAAAAAAAEAAQABABAAOQAAAAUAAQABAAEAEABAAAAABQATACYAAQAQAEcAAAAFABYA
LQABABAAWQAAAAUAHAA6AAEAEABiAAAABQAmAE8AAQAQAGoAAAAFADIAaAABARAAdgAAAAUANwBz
AAMBAACAAAAACQA3AMIAAQEQAJcAAAAFADoAwgABABAArwAAAAUAOwDNAAEBEAC5AAAABQA9ANIA
AAAQAMcA0QAFAD8A9AABABAABwESAQ0AQQD4AAMBAAA9AQAACQBBAPoAAAEQAEsB0QARAEQA+gAB
AFICMAABAHYCMAABADIEeAABAEcEfAABAGUEfAABAHwEfAABAJUEfwABALEEfwABANIEggABAO4E
fwABAAgFfwABACMFfAABADcFfwABAE0FfwABAGMFfwABAIIFhQABAKAFigABAMMFjgABAKgGfAAB
AM8GfwABAOcGfAABAMsHfAABAO0HfAABABAIfAABADEIfwABAEQIfwABAFcIxQABAHEJfAABAIsJ
ggABAKgJfAABAMAJggABAN0JfwABAPAJfwABAAMKfwABAB4KfAABADEIfwABAEQIfwABAJ8KfAAB
ADIEeAABAEcEfAABAPoKfwABABILfAABACgLfwABAEAL3QABAAgFfwABACMFfAABAFoLMAABAMMF
jgABAHQLfwABADIEeAABAPELfAABALEEfwABAAoMMAABACYMMAAGBlIOfwBWgFoOIgRWgGMOIgQR
AIkOMAQBAA8PfwABABUPfwA2AFkPfAA2AHIPfAARAHoQ1QURAKcQ2QUGBlIOfwBWgPAQ9wVWgPgQ
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
JBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEA
AAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEA
JBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEA
AAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAJBEAAAEAKhEAAAIAMhEAAAEA
MhEAAAIARBEAAAEAMhEAAAIATBEAAAEAKhEAAAIAXBEAAAMAZxEAAAQAcxEAAAUAfxEAAAYAMhEC
AAcAixEAAAEAyxEAAAIAcxEAAAMAfxEAAAEAyxEAAAIAcxEAAAMAfxEAAAQAMhEAAAEAyxEAAAIA
8BEAAAMATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAEAXBEAAAIAcxEAAAMAfxEAAAQAMhEAAAEAXBEA
AAIA8BEAAAMATBEAAAEAZxEAAAIAcxEAAAMAfxEAAAEAZxEAAAIAcxEAAAMAfxEAAAQAMhEAAAEA
ZxEAAAIA8BEAAAMATBEAAAEAyxEAAAIAcxEAAAMAfxEAAAEAyxEAAAIAcxEAAAMAfxEAAAQAMhEA
AAEAyxEAAAIA8BEAAAMATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAEAXBEAAAIAcxEAAAMAfxEAAAQA
MhEAAAEAXBEAAAIA8BEAAAMATBEAAAEAZxEAAAIAcxEAAAMAfxEAAAEAZxEAAAIAcxEAAAMAfxEA
AAQAMhEAAAEAZxEAAAIA8BEAAAMATBEAAAEAXBEAAAIAZxEAAAMAcxEAAAQAfxEAAAUAMhEAAAYA
9xEAAAEAyxEAAAIAcxEAAAMAfxEAAAEAyxEAAAIAcxEAAAMAfxEAAAQAMhEAAAEAyxEAAAIA8BEA
AAMATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAEAXBEAAAIAcxEAAAMAfxEAAAQAMhEAAAEAXBEAAAIA
8BEAAAMATBEAAAEAZxEAAAIAcxEAAAMAfxEAAAEAZxEAAAIAcxEAAAMAfxEAAAQAMhEAAAEAZxEA
AAIA8BEAAAMATBEAAAEAyxEAAAIAcxEAAAMAfxEAAAEAyxEAAAIAcxEAAAMAfxEAAAQAMhEAAAEA
yxEAAAIA8BEAAAMATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAEAXBEAAAIAcxEAAAMAfxEAAAQAMhEA
AAEAXBEAAAIA8BEAAAMATBEAAAEAZxEAAAIAcxEAAAMAfxEAAAEAZxEAAAIAcxEAAAMAfxEAAAQA
MhEAAAEAZxEAAAIA8BEAAAMATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAEAXBEAAAIAcxEAAAMAfxEA
AAQAMhEAAAEAXBEAAAIA8BEAAAMATBEAAAEAZxEAAAIAcxEAAAMAfxEAAAEAZxEAAAIAcxEAAAMA
fxEAAAQAMhEAAAEAZxEAAAIA8BEAAAMATBEAAAEAyxEAAAIAcxEAAAMAfxEAAAQACxIAAAUAExIA
AAEAyxEAAAIAcxEAAAMAfxEAAAQACxIAAAUAExIAAAYAMhEAAAEAyxEAAAIA8BEAAAMACxIAAAQA
ExIAAAUATBEAAAEAXBEAAAIAcxEAAAMAfxEAAAQACxIAAAUAExIAAAEAXBEAAAIAcxEAAAMAfxEA
AAQACxIAAAUAExIAAAYAMhEAAAEAXBEAAAIA8BEAAAMACxIAAAQAExIAAAUATBEAAAEAZxEAAAIA
cxEAAAMAfxEAAAQACxIAAAUAExIAAAEAZxEAAAIAcxEAAAMAfxEAAAQACxIAAAUAExIAAAYAMhEA
AAEAZxEAAAIA8BEAAAMACxIAAAQAExIAAAUATBEAAAEAXBEAAAIAZxEAAAMAcxEAAAQAfxEAAAUA
CxIAAAYAExIAAAcAMhEAAAEAHhIAAAIALBIAAAMAOhIAAAQACxIAAAUASBIAAAEAXBEAAAIA8BEA
AAMAUhIAAAEAyxEAAAIA8BEAAAMARBEAAAEAXBEAAAIA8BEAAAMARBEAAAEAZxEAAAIA8BEAAAMA
RBEAAAEAyxEAAAIA8BEAAAMARBEAAAEAXBEAAAIA8BEAAAMARBEAAAEAZxEAAAIA8BEAAAMARBEA
AAEAyxEAAAIA8BEAAAMARBEAAAEAXBEAAAIA8BEAAAMARBEAAAEAZxEAAAIA8BEAAAMARBEAAAEA
yxEAAAIA8BEAAAMARBEAAAEAXBEAAAIA8BEAAAMARBEAAAEAZxEAAAIA8BEAAAMARBEAAAEAXBEA
AAIA8BEAAAMARBEAAAEAZxEAAAIA8BEAAAMARBEAAAEAYBIAAAIAZRIAAAMAbhIAAAEAeBIAAAIA
fRIAAAEAJBEAAAIAfRIAAAEAJBEAAAEAJBEAAAEAXBEAAAIA8BEAAAMAhhIAAAEAohIAAAEAyxEA
AAIAfxEAAAMAMhEAAAEAyxEAAAIAfxEAAAEAyxEAAAIA8BEAAAEAyxEAAAIA8BEAAAMAhhIAAAEA
XBEAAAIA8BEAAAEAXBEAAAIA8BEAAAMAhhIAAAEAXBEAAAIA8BEAAAMAhhIAAAEAJBEAAAEAJBEA
AAEAtRIAAAIAxBIAAAEAyxEAAAIAyxIAAAMAtRIAAAQAxBIAAAEAtRIAAAIA2BIAAAEAyxEAAAIA
yxIAAAMAtRIAAAQA2BIAAAEAtRIAAAIAxBIAAAEAyxEAAAIAyxIAAAMAtRIAAAQAxBIAAAEAtRIA
AAIA4BIAAAMA5hIAAAEAyxEAAAIAyxIAAAMAtRIAAAQA4BIAAAUA5hIAAAEAtRIAAAIA2wUAAAEA
yxEAAAIAyxIAAAMAtRIAAAQA2wUAAAEAtRIAAAEAtRIAAAIA4BIAAAEAyxEAAAIAyxIAAAMAtRIA
AAQA4BIAAAEAtRIAAAIA2wUAAAEAyxEAAAIAyxIAAAMAtRIAAAQA2wUAAAEAtRIAAAIA4BIAAAEA
yxEAAAIAyxIAAAMAtRIAAAQA4BIAAAEAtRIAAAIA4BIAAAEAtRIAAAIA4BIAAAEAtRIAAAIA4BIA
AAEAyxEAAAIAyxIAAAMAtRIAAAQA4BIAAAEAtRIAAAIA7RIAAAEAtRIAAAIA7RIAAAMA4BIAAAEA
tRIAAAIA7RIAAAMA8xIAAAEAtRIAAAIA7RIAAAMA4BIAAAQA8xIAAAUA+hIAAAEAtRIAAAIA4BIA
AAMAARMAAAEAtRIAAAIA4BIAAAMAARMAAAQA8xIAAAEAtRIAAAIA4BIAAAMAARMAAAQA+hIAAAEA
tRIAAAIA4BIAAAMAARMAAAQA8xIAAAUA+hIAAAEAyxEAAAIAyxIAAAMAtRIAAAQA4BIAAAUAARMA
AAYA8xIAAAcA+hIAAAEAtRIAAAIACxMAAAEAyxEAAAIAyxIAAAMAtRIAAAQACxMAAAEAJBHRACwE
dADZACwEdADhACwEKwDpACwEKwDxACwEKwD5ACwEKwABASwEKwAJASwEKwARASwEKwAZASwEKwAh
ASwEKwApASwEQwAxASwEdAA5ASwEdAAxAIwUNAAJACwEdABBASwEKwBJAeAUCQZJAe4UDwZZAf8U
EwZJAQUVGAY5ACYVHQZhATUVIwZJATkVJwBpAVIVPwBpAWMVMwZ5ASwEKwBJAH4VOgaBAZ0VQAZp
AakVRgaJAbMVSwZJALsVUAaRASwEKwChAe4UDwapARMWZwapAR0WdAA5ACIWbQa5ATsWKwBZAEsW
cwaRASwEeAY5AFoWfga5AWoWhAZRACwEKwDBAYYWdAA5ACwEdAC5AfoMPwDJAaQWdACpAaoWdADR
ASwEpAZpACwEdADZAcsWqgY5AC8NvQY5AC8NwgbJAewWygbpAfoWDwbpAQYXSAC5AT0NDwY5AGAN
9wbZASoXEwfxATUVGQdxAU0XJwBpAVYXIQfRASwEdADRAV0XpAbRAW8XpAbRAYEXpAYBAqEXMwdp
AKgXdAA5ACwEQAdJAbYXKwBJAMcXUAdpAdUXVQdpAeMXWgdpAfAXYAcxAPgXawcxAP4XcQcMACwE
gAcxAAoYcQcUACwEgAcUABkYSAAUACYYqAcUAO4UqAcRAkoYtQfJAVsYQwDJAWQYPwBhAW4YuwcZ
AoAYDwZpAVYX2QeJAIYY4AeJALsV6gepAY8YJwBpAVYXAgiJACwEdACJAKsYGAiRACwEdAAhAsQY
JwghAtkYLgghAuUYNQgpAgQZPghBAi8ZUAhBAjYZbghBAkIZUAhBAqEXrggpAFMZughRAmYZwghZ
Ap4ZyghBAqEZ1AhBAqgZ8whBArIZ+AhBArIZGglBAiwQNglZArwZUQksACwEdABBAtMZXQk0AOwW
cgk8APoWqAcsADUVgAdBAugZrAk0APIZtwk0AP8Zwwk0AAkazwk0ABEazwlBAhoaBApBAiYaCgp5
AiwEdACBAnkaJAqBApQaLQrBACwEMwqZAiwEQAqpAiwEKwBRAmYZigqxAg8bkQoZACwEdAAhACwE
dAAIAOAAJgQIAOQAKwQIAAgBJgQIAAwBKwQgAHMAKwQuADsAoAouAEsA0AouADMA0AouAEMA1gou
AGMA7QouAGsA9gouABsAoAouACMA0AouACsA0ApAAHMAKwRgAHMAKwRhAHMAKwSAAHMAKwSBAHMA
KwShAHMAKwTBAHMAKwThAHMAKwQBAXMAKwQgAXMAKwQhAXMAKwRAAXMAKwRBAXMAKwRgAXMAKwRh
AXMAKwSAAXMAKwSBAXMAKwSgAXMAKwShAXMAKwSjAesDKwTAAXMAKwTBAXMAKwTDARMEUArgAXMA
KwThAXMAKwQAAnMAKwQBAnMAKwQgAnMAKwQhAnMAKwRAAnMAKwRBAnMAKwRgAnMAKwSAAnMAKwSB
AnMAKwSgAnMAKwShAnMAKwTAAnMAKwTBAnMAKwTgAnMAKwThAnMAKwQAA3MAKwQBA3MAKwQgA3MA
KwQhA3MAKwRAA3MAKwRBA3MAKwRgA3MAKwRhA3MAKwSAA3MAKwSBA3MAKwSgA3MAKwShA3MAKwTA
A3MAKwTBA3MAKwTgA3MAKwThA3MAKwQABHMAKwQBBHMAKwQgBHMAKwQhBHMAKwRABHMAKwRBBHMA
KwRgBHMAKwRhBHMAKwSABHMAKwSBBHMAKwShBHMAKwTABHMAKwTgBHMAKwThBHMAKwQABXMAKwQB
BXMAKwQgBXMAKwQhBXMAKwRBBXMAKwRhBXMAKwSBBXMAKwSgBXMAKwShBXMAKwTABXMAKwTBBXMA
KwTgBXMAKwThBXMAKwQABnMAKwQBBnMAKwQgBnMAKwQhBnMAKwRABnMAKwRBBnMAKwRgBnMAKwRh
BnMAKwSABnMAKwSBBnMAKwSgBnMAKwShBnMAKwTABnMAKwTBBnMAKwTgBnMAKwQAB3MAKwQpBwsE
RwpAB3MAKwRJBwsERwpgB3MAKwSAB3MAKwSgB3MAKwTAB3MAKwTgB3MAKwQACHMAKwQgCHMAKwRA
CHMAKwRgCHMAKwSACHMAKwSBCHMAKwSgCHMAKwTACHMAKwTgCHMAKwQACXMAKwQgCXMAKwRACXMA
KwRECRMAKwRgCXMAKwSACXMAKwSgCXMAKwSkCRMAKwTgCXMAKwQACnMAKwQgCnMAKwRACnMAKwRg
CnMAKwSACnMAKwSEChMAKwSgCnMAKwTACnMAKwTgCnMAKwTkChMAKwQAC3MAKwRgC3MAKwSAC3MA
KwSgC3MAKwTAC3MAKwTECxMAKwTgC3MAKwQADHMAKwQgDHMAKwQkDBMAKwRADHMAKwRgDHMAKwSA
DHMAKwSgDHMAKwTADHMAKwQADXMAKwQEDRMAKwQgDXMAKwRADXMAKwRgDXMAKwRkDRMAKwSADXMA
KwSgDXMAKwTADXMAKwTgDXMAKwQADnMAKwQgDnMAKwREDhMAKwSkDhMAKwSEDxMAKwTkDxMAKwSE
ERMAKwTkERMAKwTEEhMAKwQkExMAKwQEFBMAKwRkFBMAKwREFRMAKwSkFRMAKwSEFhMAKwTkFhMA
KwTEFxMAKwQkGBMAKwQEGRMAKwRkGRMAKwREGhMAKwSkGhMAKwQEHBMAKwSkHBMAKwQEHhMAKwSk
HhMAKwQEIBMAKwSkIBMAKwSEIRMAKwSEIhMAKwTEKRMAKwQkNRMAKwSENhMAKwQkNxMAKwQEOBMA
KwREOBMAKwTEOBMAKwQqBlUGXwaKBpAGlgadBrAG0AbjBuoG8Ab8BgYHDgcnBzoHRwdmB4YHmwet
B8MH0QfmB/MH+gcKCFgIfgiYCNsIAAkgCTwJhAmnCdoJEAo7CgIAAQADABMABAAWAAUAHAAGACYA
BwAyAAsANwANADkAEAA7AAAA2wWSAAAA3wWXAAAA7AWbAAAA9QWbAAAABAaXAAAACgaXAAAAEgag
AAAAHQagAAAALQakAAAAOAagAAAAQQagAAAASwaXAAAATgagAAAAUwagAAAAWAagAAAAZgaoAAAA
RwCuAAAAcwazAAAAAAegAAAABweXAAAADweXAAAAcgiXAAAAgwiXAAAAlQiXAAAApQigAAAApwig
AAAAqQjKAAAAOAqXAAAAQQqkAAAATQqXAAAAVAqkAAAAYAqgAAAAYgqgAAAAZAqgAAAAbgqXAAAA
pQigAAAApwigAAAA2wWSAAAA3wWXAAAAkgugAAAAmQuXAAAAngugAAAACgaXAAAApQviAAAAQQag
AAAASwaXAAAA7AWbAAAAcwazAAAArgugAAAA2wWSAAAARgyXAAAAHQagAAAATgybAAAA9QWbAAAA
Sw+gAAAAUA+gAAAAahDtBQAA4xDyBQAAHBEEBgIAAQADAAEAAgADAAIAAwAFAAEABAAFAAEABgAH
AAIABQAHAAIABwAJAAEACAAJAAIACQALAAEACgALAAIACwANAAEADAANAAIADQAPAAEADgAPAAEA
EAARAAIADwARAAIAEQATAAEAEgATAAEAFAAVAAIAEwAVAAIAFQAXAAEAFgAXAAIAFwAZAAEAGAAZ
AAIAGQAbAAEAGgAbAAEAHAAdAAIAGwAdAAEAHgAfAAIAHQAfAAIAHwAhAAEAIAAhAAEAIgAjAAIA
IQAjAAIAIwAlAAEAJAAlAAIAJgAnAAEAJwAnAAIAKAApAAEAKQApAAEAKwArAAIAKgArAAIALQAt
AAEALgAtAAIALwAvAAEAMAAvAAIAMQAxAAEAMgAxAAIAMwAzAAEANAAzAAIANQA1AAEANgA1AAIA
NwA3AAEAOAA3AAIAOgA5AAEAOwA5AAEAPQA7AAIAPAA7AAEAPwA9AAIAPgA9AAIAQAA/AAEAQQA/
AAEAQwBBAAIAQgBBAAIARABDAAEARQBDAAIARgBFAAEARwBFAAIASABHAAEASQBHAAEASwBJAAIA
SgBJAAIATABLAAEATQBLAAIATwBNAAEAUABNAAIAUQBPAAEAUgBPAAIAUwBRAAEAVABRAAIAVQBT
AAEAVgBTAAIAVwBVAAEAWABVAAIAWQBXAAEAWgBXAAIAWwBZAAEAXABZAAEAXgBbAAIAXQBbAAIA
XwBdAAEAYABdAAEAYgBfAAIAYQBfAAIAYwBhAAEAZABhAAIAZQBjAAEAZgBjAAIAaABlAAEAaQBl
AAEAawBnAAIAagBnAAIAbABpAAEAbQBpAAIAbgBrAAEAbwBrAAIAcABtAAEAcQBtAAIAzQBvAAEA
zgBvAAIAzwBxAAEA0ABxAAIA9QBzAAIA9gB1AAEA9wB1AAIA+gB3AHkHlQfvByQIVglqCXwJBIAA
AAEAAAApEcp9AAAAAAAAEgEAAAIAAAAAAAAAAAAAAAEAVAEAAAAACgAAAAAAAAAAAAAACgBwAQAA
AAACAAAAAAAAAAAAAAABAF0BAAAAAAEAAwABAP0QAAAAABMAAQIAAAAAAgAAAAAAAAAAAAAAAQBZ
DAAAAAACAAAAAAAAAAAAAAABAEsNAAAAAAEAAwABAP0QAAAAABMAgw8AAAAAAwAFAAAAAAAAAAAA
AQDlGgAAAAAAAAAAAQAAABMbAAAJAAgADwAOAAAAAAClAasPAAAAAKcBqw8AAAAAqQGrDwAAAACr
AasPAAAAAK0Bqw8AAAAArwGrDwAAAACxAasPAAAAALMBqw8AAAAAvwGrDwAAAADBAasPAAAAAMMB
qw8AAAAAxQGrDwAAAADLAasPAAAAAM0Bqw8AAAAAzwGrDwAAAADRAasPAAAAANMBqw8AAAAA1QGr
DwAAAADXAasPAAAAANkBqw8AAAAA2wGrDwAAAADdAasPAAAAAN8Bqw+mAR8IxwBKCMkAHwiqAR8I
ywAfCK4BHwjNAB8IsgEfCMABHwjbAB8IxAEfCN0AHwjMAR8I5QAfCNQBHwjeAR8I7QAfCLABmwoA
AAA8TW9kdWxlPgBTVF83MWNmYjMxMWExOGQ0YjVmOTA4NmQ3MTdkMGZhNGM2Yi5jc3Byb2ouZGxs
AE1fUG9zdABNX1VzZXIAQ2FyZEZvcm1hdGlvbkluZm8AQ2FyZEluZm8AQ29tbWVudABDdXN0b21l
clRhZwBTcWxIZWxwZXIAU3FsQ29ubmVjdGlvbk93bmVyc2hpcABTcWxIZWxwZXJQYXJhbWV0ZXJD
YWNoZQBQYWdlckluZm8ATW9uZ29EQkhlbHBlcgBSZXNvdXJjZXMAU1RfNzFjZmIzMTFhMThkNGI1
ZjkwODZkNzE3ZDBmYTRjNmIuY3Nwcm9qLlByb3BlcnRpZXMAU2NyaXB0TWFpbgBTVF83MWNmYjMx
MWExOGQ0YjVmOTA4NmQ3MTdkMGZhNGM2Yi5jc3Byb2oAU2NyaXB0UmVzdWx0cwBTZXR0aW5ncwBt
c2NvcmxpYgBTeXN0ZW0AT2JqZWN0AEVudW0ATWljcm9zb2Z0LlNxbFNlcnZlci5TY3JpcHRUYXNr
AE1pY3Jvc29mdC5TcWxTZXJ2ZXIuRHRzLlRhc2tzLlNjcmlwdFRhc2sAVlNUQVJUU2NyaXB0T2Jq
ZWN0TW9kZWxCYXNlAFN5c3RlbS5Db25maWd1cmF0aW9uAEFwcGxpY2F0aW9uU2V0dGluZ3NCYXNl
AE1vbmdvREIuQnNvbgBPYmplY3RJZABnZXRfX2lkAHNldF9faWQAZ2V0X19pZEZvclN0cmluZwBz
ZXRfX2lkRm9yU3RyaW5nAERhdGVUaW1lAF9Qb3N0VGltZQBnZXRfUG9zdFRpbWUAc2V0X1Bvc3RU
aW1lAF9MYXN0TW9kaWZ5VGltZQBnZXRfTGFzdE1vZGlmeVRpbWUAc2V0X0xhc3RNb2RpZnlUaW1l
AGdldF9UaXRsZQBzZXRfVGl0bGUAZ2V0X0NvbnRlbnQAc2V0X0NvbnRlbnQAZ2V0X1JlcGx5Q291
bnQAc2V0X1JlcGx5Q291bnQAZ2V0X1BvcHVsYXJpdHlDb3VudABzZXRfUG9wdWxhcml0eUNvdW50
AGdldF9BdWRpdFN0YXRlAHNldF9BdWRpdFN0YXRlAGdldF9Qb3N0VHlwZQBzZXRfUG9zdFR5cGUA
Z2V0X1Bvc3RTdGF0ZQBzZXRfUG9zdFN0YXRlAGdldF9JUABzZXRfSVAAZ2V0X01hcmsAc2V0X01h
cmsAZ2V0X0Rvd24Ac2V0X0Rvd24AZ2V0X0FsbFRha2VQYXJ0SW4Ac2V0X0FsbFRha2VQYXJ0SW4A
Z2V0X0N1c3RvbWVyVGFncwBzZXRfQ3VzdG9tZXJUYWdzAGdldF9DYXJkRm9ybWF0aW9uSW5mbwBz
ZXRfQ2FyZEZvcm1hdGlvbkluZm8AZ2V0X21fVXNlcgBzZXRfbV9Vc2VyAC5jdG9yADxfaWQ+a19f
QmFja2luZ0ZpZWxkADxfaWRGb3JTdHJpbmc+a19fQmFja2luZ0ZpZWxkADxUaXRsZT5rX19CYWNr
aW5nRmllbGQAPENvbnRlbnQ+a19fQmFja2luZ0ZpZWxkADxSZXBseUNvdW50PmtfX0JhY2tpbmdG
aWVsZAA8UG9wdWxhcml0eUNvdW50PmtfX0JhY2tpbmdGaWVsZAA8QXVkaXRTdGF0ZT5rX19CYWNr
aW5nRmllbGQAPFBvc3RUeXBlPmtfX0JhY2tpbmdGaWVsZAA8UG9zdFN0YXRlPmtfX0JhY2tpbmdG
aWVsZAA8SVA+a19fQmFja2luZ0ZpZWxkADxNYXJrPmtfX0JhY2tpbmdGaWVsZAA8RG93bj5rX19C
YWNraW5nRmllbGQAPEFsbFRha2VQYXJ0SW4+a19fQmFja2luZ0ZpZWxkADxDdXN0b21lclRhZ3M+
a19fQmFja2luZ0ZpZWxkADxDYXJkRm9ybWF0aW9uSW5mbz5rX19CYWNraW5nRmllbGQAPG1fVXNl
cj5rX19CYWNraW5nRmllbGQAX2lkAF9pZEZvclN0cmluZwBQb3N0VGltZQBMYXN0TW9kaWZ5VGlt
ZQBUaXRsZQBDb250ZW50AFJlcGx5Q291bnQAUG9wdWxhcml0eUNvdW50AEF1ZGl0U3RhdGUAUG9z
dFR5cGUAUG9zdFN0YXRlAElQAE1hcmsARG93bgBBbGxUYWtlUGFydEluAEN1c3RvbWVyVGFncwBt
X1VzZXIAZ2V0X1VzZXJJRABzZXRfVXNlcklEAGdldF9OaWNOYW1lAHNldF9OaWNOYW1lAF9BdmF0
YXJVUkwAZ2V0X0F2YXRhclVSTABzZXRfQXZhdGFyVVJMADxVc2VySUQ+a19fQmFja2luZ0ZpZWxk
ADxOaWNOYW1lPmtfX0JhY2tpbmdGaWVsZABVc2VySUQATmljTmFtZQBBdmF0YXJVUkwAZ2V0X0Nh
cmRGb3JtYXRpb25VcmwAc2V0X0NhcmRGb3JtYXRpb25VcmwAZ2V0X0NhcmRGb3JtYXRpb25OYW1l
AHNldF9DYXJkRm9ybWF0aW9uTmFtZQBnZXRfQ2FyZEZvcm1hdGlvbklEAHNldF9DYXJkRm9ybWF0
aW9uSUQAZ2V0X1cAc2V0X1cAZ2V0X0gAc2V0X0gAZ2V0X0NhcmRJbmZvcwBzZXRfQ2FyZEluZm9z
ADxDYXJkRm9ybWF0aW9uVXJsPmtfX0JhY2tpbmdGaWVsZAA8Q2FyZEZvcm1hdGlvbk5hbWU+a19f
QmFja2luZ0ZpZWxkADxDYXJkRm9ybWF0aW9uSUQ+a19fQmFja2luZ0ZpZWxkADxXPmtfX0JhY2tp
bmdGaWVsZAA8SD5rX19CYWNraW5nRmllbGQAPENhcmRJbmZvcz5rX19CYWNraW5nRmllbGQAQ2Fy
ZEZvcm1hdGlvblVybABDYXJkRm9ybWF0aW9uTmFtZQBDYXJkRm9ybWF0aW9uSUQAVwBIAENhcmRJ
bmZvcwBnZXRfQ2FyZE5hbWUAc2V0X0NhcmROYW1lAGdldF9Jc0hhbmRzdGFuZABzZXRfSXNIYW5k
c3RhbmQAZ2V0X0ltZ1VybABzZXRfSW1nVXJsAGdldF9Jc1BvaW50Q2FyZABzZXRfSXNQb2ludENh
cmQAZ2V0X1gAc2V0X1gAZ2V0X1kAc2V0X1kAZ2V0X1NvcnRJbmRleABzZXRfU29ydEluZGV4AGdl
dF9EZXNjcmliZQBzZXRfRGVzY3JpYmUAPENhcmROYW1lPmtfX0JhY2tpbmdGaWVsZAA8SXNIYW5k
c3RhbmQ+a19fQmFja2luZ0ZpZWxkADxJbWdVcmw+a19fQmFja2luZ0ZpZWxkADxJc1BvaW50Q2Fy
ZD5rX19CYWNraW5nRmllbGQAPFg+a19fQmFja2luZ0ZpZWxkADxZPmtfX0JhY2tpbmdGaWVsZAA8
U29ydEluZGV4PmtfX0JhY2tpbmdGaWVsZAA8RGVzY3JpYmU+a19fQmFja2luZ0ZpZWxkAENhcmRO
YW1lAElzSGFuZHN0YW5kAEltZ1VybABJc1BvaW50Q2FyZABYAFkAU29ydEluZGV4AERlc2NyaWJl
AGdldF9fSW5kZXgAc2V0X19JbmRleABnZXRfRktpZABzZXRfRktpZABfQ29udGVudABnZXRfRktU
eXBlAHNldF9GS1R5cGUAZ2V0X0NoaWxkcmVuAHNldF9DaGlsZHJlbgBnZXRfQ29tbWVudExldmVs
AHNldF9Db21tZW50TGV2ZWwAPF9JbmRleD5rX19CYWNraW5nRmllbGQAPEZLaWQ+a19fQmFja2lu
Z0ZpZWxkADxGS1R5cGU+a19fQmFja2luZ0ZpZWxkADxDaGlsZHJlbj5rX19CYWNraW5nRmllbGQA
PFBvc3RUaW1lPmtfX0JhY2tpbmdGaWVsZAA8Q29tbWVudExldmVsPmtfX0JhY2tpbmdGaWVsZABf
SW5kZXgARktpZABGS1R5cGUAQ2hpbGRyZW4AQ29tbWVudExldmVsAGdldF9UYWdOYW1lAHNldF9U
YWdOYW1lAGdldF9DcmVhdGVUaW1lAHNldF9DcmVhdGVUaW1lADxUYWdOYW1lPmtfX0JhY2tpbmdG
aWVsZAA8Q3JlYXRlVGltZT5rX19CYWNraW5nRmllbGQAPExhc3RNb2RpZnlUaW1lPmtfX0JhY2tp
bmdGaWVsZABUYWdOYW1lAENyZWF0ZVRpbWUAU3lzdGVtLkRhdGEAU3lzdGVtLkRhdGEuU3FsQ2xp
ZW50AFNxbENvbW1hbmQAU3FsUGFyYW1ldGVyAEF0dGFjaFBhcmFtZXRlcnMARGF0YVJvdwBBc3Np
Z25QYXJhbWV0ZXJWYWx1ZXMAU3FsQ29ubmVjdGlvbgBTcWxUcmFuc2FjdGlvbgBDb21tYW5kVHlw
ZQBQcmVwYXJlQ29tbWFuZABFeGVjdXRlTm9uUXVlcnkARGF0YVNldABFeGVjdXRlRGF0YXNldABT
cWxEYXRhUmVhZGVyAEV4ZWN1dGVSZWFkZXIARXhlY3V0ZVNjYWxhcgBTeXN0ZW0uWG1sAFhtbFJl
YWRlcgBFeGVjdXRlWG1sUmVhZGVyAEZpbGxEYXRhc2V0AFVwZGF0ZURhdGFzZXQAQ3JlYXRlQ29t
bWFuZABFeGVjdXRlTm9uUXVlcnlUeXBlZFBhcmFtcwBFeGVjdXRlRGF0YXNldFR5cGVkUGFyYW1z
AEV4ZWN1dGVSZWFkZXJUeXBlZFBhcmFtcwBFeGVjdXRlU2NhbGFyVHlwZWRQYXJhbXMARXhlY3V0
ZVhtbFJlYWRlclR5cGVkUGFyYW1zAFNlY0xpa2UATnVsbGFibGVgMQBTZWNEYXRlAFNlY0ludABT
ZWNJbnRNYXgAU2VjSW50TWluAHZhbHVlX18ASW50ZXJuYWwARXh0ZXJuYWwAU3lzdGVtLkNvbGxl
Y3Rpb25zAEhhc2h0YWJsZQBwYXJhbUNhY2hlAERpc2NvdmVyU3BQYXJhbWV0ZXJTZXQAQ2xvbmVQ
YXJhbWV0ZXJzAENhY2hlUGFyYW1ldGVyU2V0AEdldENhY2hlZFBhcmFtZXRlclNldABHZXRTcFBh
cmFtZXRlclNldABHZXRTcFBhcmFtZXRlclNldEludGVybmFsAF9QYWdlAF9QYWdlU2l6ZQBnZXRf
UGFnZQBzZXRfUGFnZQBnZXRfUGFnZVNpemUAc2V0X1BhZ2VTaXplAFBhZ2UAUGFnZVNpemUAY29u
bmVjdGlvblN0cmluZ19EZWZhdWx0AGRhdGFiYXNlX0RlZmF1bHQATW9uZ29EQi5Ecml2ZXIAU2Fm
ZU1vZGVSZXN1bHQASW5zZXJ0T25lAFQAU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWMASUVudW1l
cmFibGVgMQBJbnNlcnRBbGwAVXBkYXRlT25lAElNb25nb1F1ZXJ5AElNb25nb1VwZGF0ZQBVcGRh
dGVBbGwARGVsZXRlAERlbGV0ZUFsbABHZXRPbmUARXhpc3RzAENvdW50AExpc3RgMQBHZXRBbGwA
SU1vbmdvU29ydEJ5AENyZWF0ZUluZGV4AFN5c3RlbS5SZXNvdXJjZXMAUmVzb3VyY2VNYW5hZ2Vy
AHJlc291cmNlTWFuAFN5c3RlbS5HbG9iYWxpemF0aW9uAEN1bHR1cmVJbmZvAHJlc291cmNlQ3Vs
dHVyZQBnZXRfUmVzb3VyY2VNYW5hZ2VyAGdldF9DdWx0dXJlAHNldF9DdWx0dXJlAEN1bHR1cmUA
TWFpbgBTdWNjZXNzAEZhaWx1cmUAZGVmYXVsdEluc3RhbmNlAGdldF9EZWZhdWx0AERlZmF1bHQA
dmFsdWUAY29tbWFuZABjb21tYW5kUGFyYW1ldGVycwBkYXRhUm93AHBhcmFtZXRlclZhbHVlcwBj
b25uZWN0aW9uAHRyYW5zYWN0aW9uAGNvbW1hbmRUeXBlAGNvbW1hbmRUZXh0AG11c3RDbG9zZUNv
bm5lY3Rpb24AU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzAE91dEF0dHJpYnV0ZQBjb25u
ZWN0aW9uU3RyaW5nAFBhcmFtQXJyYXlBdHRyaWJ1dGUAc3BOYW1lAGNvbm5lY3Rpb25Pd25lcnNo
aXAAZGF0YVNldAB0YWJsZU5hbWVzAGluc2VydENvbW1hbmQAZGVsZXRlQ29tbWFuZAB1cGRhdGVD
b21tYW5kAHRhYmxlTmFtZQBzb3VyY2VDb2x1bW5zAGxpa2UAcHJlTWF0Y2gAbGFzdE1hdGNoAGRh
dGUAbnVsbGFibGUAaW5jbHVkZVJldHVyblZhbHVlUGFyYW1ldGVyAG9yaWdpbmFsUGFyYW1ldGVy
cwBjb2xsZWN0aW9uTmFtZQBlbnRpdHkAZGF0YWJhc2VOYW1lAGVudGl0eXMAcXVlcnkAdXBkYXRl
AGNvdW50AHNvcnRCeQBmaWVsZHMAcGFnZXJJbmZvAGtleU5hbWVzAFN5c3RlbS5SZWZsZWN0aW9u
AEFzc2VtYmx5VGl0bGVBdHRyaWJ1dGUAQXNzZW1ibHlEZXNjcmlwdGlvbkF0dHJpYnV0ZQBBc3Nl
bWJseUNvbmZpZ3VyYXRpb25BdHRyaWJ1dGUAQXNzZW1ibHlDb21wYW55QXR0cmlidXRlAEFzc2Vt
Ymx5UHJvZHVjdEF0dHJpYnV0ZQBBc3NlbWJseUNvcHlyaWdodEF0dHJpYnV0ZQBBc3NlbWJseVRy
YWRlbWFya0F0dHJpYnV0ZQBBc3NlbWJseUN1bHR1cmVBdHRyaWJ1dGUAQXNzZW1ibHlWZXJzaW9u
QXR0cmlidXRlAFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXMAQ29tcGlsYXRpb25SZWxh
eGF0aW9uc0F0dHJpYnV0ZQBSdW50aW1lQ29tcGF0aWJpbGl0eUF0dHJpYnV0ZQBDb21waWxlckdl
bmVyYXRlZEF0dHJpYnV0ZQBUb0xvY2FsVGltZQBBcmd1bWVudE51bGxFeGNlcHRpb24AU3lzdGVt
LkRhdGEuQ29tbW9uAERiUGFyYW1ldGVyAFBhcmFtZXRlckRpcmVjdGlvbgBnZXRfRGlyZWN0aW9u
AGdldF9WYWx1ZQBEQk51bGwAVmFsdWUAc2V0X1ZhbHVlAFNxbFBhcmFtZXRlckNvbGxlY3Rpb24A
Z2V0X1BhcmFtZXRlcnMAQWRkAGdldF9QYXJhbWV0ZXJOYW1lAFN0cmluZwBnZXRfTGVuZ3RoAElu
dDMyAEZvcm1hdABFeGNlcHRpb24ARGF0YVRhYmxlAGdldF9UYWJsZQBEYXRhQ29sdW1uQ29sbGVj
dGlvbgBnZXRfQ29sdW1ucwBTdWJzdHJpbmcASW5kZXhPZgBnZXRfSXRlbQBBcmd1bWVudEV4Y2Vw
dGlvbgBJRGJEYXRhUGFyYW1ldGVyAElEYXRhUGFyYW1ldGVyAERiQ29ubmVjdGlvbgBDb25uZWN0
aW9uU3RhdGUAZ2V0X1N0YXRlAE9wZW4Ac2V0X0Nvbm5lY3Rpb24ARGJDb21tYW5kAHNldF9Db21t
YW5kVGV4dABnZXRfQ29ubmVjdGlvbgBzZXRfVHJhbnNhY3Rpb24Ac2V0X0NvbW1hbmRUeXBlAElE
aXNwb3NhYmxlAERpc3Bvc2UARGJQYXJhbWV0ZXJDb2xsZWN0aW9uAENsZWFyAENsb3NlAFNxbERh
dGFBZGFwdGVyAERhdGFBZGFwdGVyAEZpbGwAQ29tbWFuZEJlaGF2aW9yAElFbnVtZXJhdG9yAEdl
dEVudW1lcmF0b3IAZ2V0X0N1cnJlbnQATW92ZU5leHQARGF0YVRhYmxlTWFwcGluZ0NvbGxlY3Rp
b24AZ2V0X1RhYmxlTWFwcGluZ3MARGF0YVRhYmxlTWFwcGluZwBUb1N0cmluZwBDb25jYXQAc2V0
X1VwZGF0ZUNvbW1hbmQAc2V0X0luc2VydENvbW1hbmQAc2V0X0RlbGV0ZUNvbW1hbmQARGJEYXRh
QWRhcHRlcgBVcGRhdGUAQWNjZXB0Q2hhbmdlcwBzZXRfU291cmNlQ29sdW1uAGdldF9JdGVtQXJy
YXkASXNOdWxsT3JFbXB0eQBSZXBsYWNlAENoYXIAVHJpbUVuZABQYXJzZQBvcF9MZXNzVGhhbgBv
cF9HcmVhdGVyVGhhbgBnZXRfSGFzVmFsdWUAR2V0VmFsdWVPckRlZmF1bHQAU3FsQ29tbWFuZEJ1
aWxkZXIARGVyaXZlUGFyYW1ldGVycwBSZW1vdmVBdABnZXRfQ291bnQAQ29weVRvAElDbG9uZWFi
bGUAQ2xvbmUAc2V0X0l0ZW0AZ2V0X0Nvbm5lY3Rpb25TdHJpbmcALmNjdG9yAFN5bmNocm9uaXpl
ZABNb25nb1NlcnZlcgBDcmVhdGUATW9uZ29EYXRhYmFzZQBHZXREYXRhYmFzZQBSZXF1ZXN0U3Rh
cnQATW9uZ29Db2xsZWN0aW9uYDEAR2V0Q29sbGVjdGlvbgBCc29uRG9jdW1lbnQATW9uZ29Db2xs
ZWN0aW9uAEluc2VydABJbnNlcnRCYXRjaABTYXZlAFVwZGF0ZUZsYWdzAFRyeVBhcnNlAEJzb25W
YWx1ZQBvcF9JbXBsaWNpdABNb25nb0RCLkRyaXZlci5CdWlsZGVycwBRdWVyeQBRdWVyeUNvbXBs
ZXRlAEVRAFJlbW92ZQBSZW1vdmVBbGwARmluZE9uZUFzAGdldF9OdWxsAE1vbmdvQ3Vyc29yYDEA
RmluZEFzAElFbnVtZXJhdG9yYDEARmluZEFsbEFzAFNldFNvcnRPcmRlcgBTZXRGaWVsZHMAU2V0
U2tpcABTZXRMaW1pdABJbmRleEV4aXN0cwBFbnN1cmVJbmRleABTeXN0ZW0uRGlhZ25vc3RpY3MA
RGVidWdnZXJOb25Vc2VyQ29kZUF0dHJpYnV0ZQBUeXBlAFJ1bnRpbWVUeXBlSGFuZGxlAEdldFR5
cGVGcm9tSGFuZGxlAEFzc2VtYmx5AGdldF9Bc3NlbWJseQBTeXN0ZW0uQ29tcG9uZW50TW9kZWwA
RWRpdG9yQnJvd3NhYmxlQXR0cmlidXRlAEVkaXRvckJyb3dzYWJsZVN0YXRlAFN5c3RlbS5BZGRJ
bgBBZGRJbkF0dHJpYnV0ZQBVcGRhdGVCdWlsZGVyAFNldABTVF83MWNmYjMxMWExOGQ0YjVmOTA4
NmQ3MTdkMGZhNGM2Yi5jc3Byb2ouUHJvcGVydGllcy5SZXNvdXJjZXMucmVzb3VyY2VzAAAAAAAP
YwBvAG0AbQBhAG4AZAAAgO9QAGwAZQBhAHMAZQAgAHAAcgBvAHYAaQBkAGUAIABhACAAdgBhAGwA
aQBkACAAcABhAHIAYQBtAGUAdABlAHIAIABuAGEAbQBlACAAbwBuACAAdABoAGUAIABwAGEAcgBh
AG0AZQB0AGUAcgAgACMAewAwAH0ALAAgAHQAaABlACAAUABhAHIAYQBtAGUAdABlAHIATgBhAG0A
ZQAgAHAAcgBvAHAAZQByAHQAeQAgAGgAYQBzACAAdABoAGUAIABmAG8AbABsAG8AdwBpAG4AZwAg
AHYAYQBsAHUAZQA6ACAAJwB7ADEAfQAnAC4AAWtQAGEAcgBhAG0AZQB0AGUAcgAgAGMAbwB1AG4A
dAAgAGQAbwBlAHMAIABuAG8AdAAgAG0AYQB0AGMAaAAgAFAAYQByAGEAbQBlAHQAZQByACAAVgBh
AGwAdQBlACAAYwBvAHUAbgB0AC4AABdjAG8AbQBtAGEAbgBkAFQAZQB4AHQAAICfVABoAGUAIAB0
AHIAYQBuAHMAYQBjAHQAaQBvAG4AIAB3AGEAcwAgAHIAbwBsAGwAYgBhAGMAawBlAGQAIABvAHIA
IABjAG8AbQBtAGkAdABlAGQALAAgAHAAbABlAGEAcwBlACAAcAByAG8AdgBpAGQAZQAgAGEAbgAg
AG8AcABlAG4AIAB0AHIAYQBuAHMAYQBjAHQAaQBvAG4ALgAAF3QAcgBhAG4AcwBhAGMAdABpAG8A
bgAAIWMAbwBuAG4AZQBjAHQAaQBvAG4AUwB0AHIAaQBuAGcAAA1zAHAATgBhAG0AZQAAFWMAbwBu
AG4AZQBjAHQAaQBvAG4AAA9kAGEAdABhAFMAZQB0AAALVABhAGIAbABlAACAy1QAaABlACAAdABh
AGIAbABlAE4AYQBtAGUAcwAgAHAAYQByAGEAbQBlAHQAZQByACAAbQB1AHMAdAAgAGMAbwBuAHQA
YQBpAG4AIABhACAAbABpAHMAdAAgAG8AZgAgAHQAYQBiAGwAZQBzACwAIABhACAAdgBhAGwAdQBl
ACAAdwBhAHMAIABwAHIAbwB2AGkAZABlAGQAIABhAHMAIABuAHUAbABsACAAbwByACAAZQBtAHAA
dAB5ACAAcwB0AHIAaQBuAGcALgAAFXQAYQBiAGwAZQBOAGEAbQBlAHMAABtpAG4AcwBlAHIAdABD
AG8AbQBtAGEAbgBkAAAbZABlAGwAZQB0AGUAQwBvAG0AbQBhAG4AZAAAG3UAcABkAGEAdABlAEMA
bwBtAG0AYQBuAGQAABN0AGEAYgBsAGUATgBhAG0AZQAAA1sAAAdbAFsAXQAAAyUAAAdbACUAXQAA
AQArMQAvADEALwAxADcANQAzACAAMQAyADoAMAAwADoAMAAwACAAQQBNACAAAC0xADIALwAzADEA
LwA5ADkAOQA5ACAAMQAxADoANQA5ADoANQA5ACAAUABNAAADOgAAPToAaQBuAGMAbAB1AGQAZQAg
AFIAZQB0AHUAcgBuAFYAYQBsAHUAZQAgAFAAYQByAGEAbQBlAHQAZQByAAAHXwBpAGQAACFTAGUA
cgB2AGUAcgA9ADEAMgA3AC4AMAAuADAALgAxAAALVABhAHIAbwB0AAB/UwBUAF8ANwAxAGMAZgBi
ADMAMQAxAGEAMQA4AGQANABiADUAZgA5ADAAOAA2AGQANwAxADcAZAAwAGYAYQA0AGMANgBiAC4A
YwBzAHAAcgBvAGoALgBQAHIAbwBwAGUAcgB0AGkAZQBzAC4AUgBlAHMAbwB1AHIAYwBlAHMAAAtQ
AG8AcwB0AHMAABFDAG8AbQBtAGUAbgB0AHMAABdDAHUAcwB0AG8AbQBlAHIAVABhAGcAAB9QAG8A
cAB1AGwAYQByAGkAdAB5AEMAbwB1AG4AdAAAgMtEAGEAdABhACAAUwBvAHUAcgBjAGUAPQAuADsA
SQBuAGkAdABpAGEAbAAgAEMAYQB0AGEAbABvAGcAPQBUAGEAcgBvAHQAOwBQAGUAcgBzAGkAcwB0
ACAAUwBlAGMAdQByAGkAdAB5ACAASQBuAGYAbwA9AFQAcgB1AGUAOwBVAHMAZQByACAASQBEAD0A
cwBhADsAUABhAHMAcwB3AG8AcgBkAD0AcwBhADEAMgAzADQAOwB0AGkAbQBlAG8AdQB0AD0AMgA0
ADAAAEt1AHAAZABhAHQAZQAgAEMAYQByAGQARgBvAHIAbQBhAHQAaQBvAG4AIABzAGUAdAAgAFAA
bwBwAHUAbABhAHIAaQB0AHkAPQAwAAAAIpjAq+V+006RcDCxX5ElEQAIt3pcVhk04IkIiYRdzYCA
zJEI9oZzHPucwQMEIAARFQUgAQERFQMgAA4EIAEBDgMGERkEIAARGQUgAQERGQMgAAgEIAEBCAMg
AAIEIAEBAgUgAB0SHAYgAQEdEhwEIAASEAUgAQESEAQgABIMBSABARIMAyAAAQMGERUCBg4CBggC
BgIEBh0SHAMGEhADBhIMBCgAERUDKAAOBCgAERkDKAAIAygAAgUoAB0SHAQoABIQBCgAEgwFIAAd
EhQGIAEBHRIUBAYdEhQFKAAdEhQFIAAdEhgGIAEBHRIYBAYdEhgFKAAdEhgIAAIBEh0dEiEIAAIB
HRIhEiUIAAIBHRIhHRwRAAcBEh0SKRItETEOHRIhEAIHAAMIDhExDgoABAgOETEOHRIhBwADCA4O
HRwIAAMIEikRMQ4LAAQIEikRMQ4dEiEIAAMIEikOHRwIAAMIEi0RMQ4LAAQIEi0RMQ4dEiEIAAMI
Ei0OHRwIAAMSNQ4RMQ4LAAQSNQ4RMQ4dEiEIAAMSNQ4OHRwJAAMSNRIpETEODAAEEjUSKRExDh0S
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAQAQAAAAGAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAMAAAgAAAAAAAAAAAAAAAAAAAAQAAAAAA
SAAAAFjAAADwAwAAAAAAAAAAAADwAzQAAABWAFMAXwBWAEUAUgBTAEkATwBOAF8ASQBOAEYATwAA
AAAAvQTv/gAAAQAAAAEAyn0pEQAAAQDKfSkRPwAAAAAAAAAEAAAAAgAAAAAAAAAAAAAAAAAAAEQA
AAABAFYAYQByAEYAaQBsAGUASQBuAGYAbwAAAAAAJAAEAAAAVAByAGEAbgBzAGwAYQB0AGkAbwBu
AAAAAAAAALAEUAMAAAEAUwB0AHIAaQBuAGcARgBpAGwAZQBJAG4AZgBvAAAALAMAAAEAMAAwADAA
MAAwADQAYgAwAAAAgAArAAEARgBpAGwAZQBEAGUAcwBjAHIAaQBwAHQAaQBvAG4AAAAAAFMAVABf
ADcAMQBjAGYAYgAzADEAMQBhADEAOABkADQAYgA1AGYAOQAwADgANgBkADcAMQA3AGQAMABmAGEA
NABjADYAYgAuAGMAcwBwAHIAbwBqAAAAAABAAA8AAQBGAGkAbABlAFYAZQByAHMAaQBvAG4AAAAA
ADEALgAwAC4ANAAzADkAMwAuADMAMgAyADAAMgAAAAAAgAAvAAEASQBuAHQAZQByAG4AYQBsAE4A
YQBtAGUAAABTAFQAXwA3ADEAYwBmAGIAMwAxADEAYQAxADgAZAA0AGIANQBmADkAMAA4ADYAZAA3
ADEANwBkADAAZgBhADQAYwA2AGIALgBjAHMAcAByAG8AagAuAGQAbABsAAAAAABIABIAAQBMAGUA
ZwBhAGwAQwBvAHAAeQByAGkAZwBoAHQAAABDAG8AcAB5AHIAaQBnAGgAdAAgAEAAIAAgADIAMAAx
ADIAAACIAC8AAQBPAHIAaQBnAGkAbgBhAGwARgBpAGwAZQBuAGEAbQBlAAAAUwBUAF8ANwAxAGMA
ZgBiADMAMQAxAGEAMQA4AGQANABiADUAZgA5ADAAOAA2AGQANwAxADcAZAAwAGYAYQA0AGMANgBi
AC4AYwBzAHAAcgBvAGoALgBkAGwAbAAAAAAAeAArAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAA
AABTAFQAXwA3ADEAYwBmAGIAMwAxADEAYQAxADgAZAA0AGIANQBmADkAMAA4ADYAZAA3ADEANwBk
ADAAZgBhADQAYwA2AGIALgBjAHMAcAByAG8AagAAAAAARAAPAAEAUAByAG8AZAB1AGMAdABWAGUA
cgBzAGkAbwBuAAAAMQAuADAALgA0ADMAOQAzAC4AMwAyADIAMAAyAAAAAABIAA8AAQBBAHMAcwBl
AG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgA0ADMAOQAzAC4AMwAyADIAMAAyAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAMAAAAgDQAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</BinaryItem></ScriptProject></DTS:ObjectData></DTS:Executable>
<DTS:Executable DTS:ExecutableType="Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" DTS:ThreadHint="1">
<DTS:Property DTS:Name="ExecutionLocation">0</DTS:Property>
<DTS:Property DTS:Name="ExecutionAddress"></DTS:Property>
<DTS:Property DTS:Name="TaskContact">Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1</DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">-1</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Property DTS:Name="ObjectName">设置时间</DTS:Property>
<DTS:Property DTS:Name="DTSID">{1d23ce21-6f54-4c25-a9e7-b0b414fc0619}</DTS:Property>
<DTS:Property DTS:Name="Description">执行 SQL 任务</DTS:Property>
<DTS:Property DTS:Name="CreationName">Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property><DTS:ObjectData><SQLTask:SqlTaskData SQLTask:Connection="{C66B6D20-0808-44B0-9B6A-CEFCBD06B0A2}" SQLTask:TimeOut="0" SQLTask:IsStoredProc="False" SQLTask:BypassPrepare="True" SQLTask:SqlStmtSourceType="DirectInput" SQLTask:SqlStatementSource="select top 1 createtime from TaskRunLog where isSuccess=1 order by createtime desc" SQLTask:CodePage="936" SQLTask:ResultType="ResultSetType_SingleRow" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask"><SQLTask:ResultBinding SQLTask:ResultName="0" SQLTask:DtsVariableName="User::StartTime"/></SQLTask:SqlTaskData></DTS:ObjectData></DTS:Executable>
<DTS:Executable DTS:ExecutableType="Microsoft.SqlServer.Dts.Tasks.ScriptTask.ScriptTask, Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" DTS:ThreadHint="2">
<DTS:Property DTS:Name="ExecutionLocation">0</DTS:Property>
<DTS:Property DTS:Name="ExecutionAddress"></DTS:Property>
<DTS:Property DTS:Name="TaskContact"></DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">-1</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Property DTS:Name="ObjectName">脚本任务 1</DTS:Property>
<DTS:Property DTS:Name="DTSID">{55DAADFA-41CF-437B-B10A-8CA728794074}</DTS:Property>
<DTS:Property DTS:Name="Description">脚本任务</DTS:Property>
<DTS:Property DTS:Name="CreationName">Microsoft.SqlServer.Dts.Tasks.ScriptTask.ScriptTask, Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property><DTS:ObjectData><ScriptProject Name="ST_26f00f5f5cb84de6a4ad88a38c37f72c" VSTAMajorVersion="2" VSTAMinorVersion="1" Language="CSharp" EntryPoint="Main" ReadOnlyVariables="User::StartTime" ReadWriteVariables=""><ProjectItem Name="\properties\resources.resx">
<![CDATA[<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>]]></ProjectItem><ProjectItem Name="\properties\settings.designer.cs">
<![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Settings.get_Default():ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Sett" +
    "ings")]

namespace ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties
{


    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        private static Settings defaultInstance = new Settings();

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}]]></ProjectItem><ProjectItem Name="\properties\settings.settings">
<![CDATA[<?xml version='1.0' encoding='iso-8859-1'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>]]></ProjectItem><ProjectItem Name="\properties\assemblyinfo.cs">
<![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj")]
[assembly: AssemblyCopyright("Copyright @  2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]]]></ProjectItem><ProjectItem Name="\model.cs">
<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MongoDB.Bson;


public class M_Post
{
    //[MongoID]
    public ObjectId _id { get; set; }
    public string _idForString { get; set; }

    private DateTime _PostTime;
    public DateTime PostTime { get { return _PostTime.ToLocalTime(); } set { _PostTime = value; } }
    private DateTime _LastModifyTime;
    public DateTime LastModifyTime { get { return _LastModifyTime.ToLocalTime(); } set { _LastModifyTime = value; } }

    public string Title { get; set; }
    /// <summary>
    /// 帖子内容
    /// </summary>
    public string Content { get; set; }

    public int ReplyCount { get; set; }
    /// <summary>
    /// 人气
    /// </summary>
    public int PopularityCount { get; set; }
    /// <summary>
    /// 审核状态
    /// </summary>
    public bool AuditState { get; set; }

    /// <summary>
    /// 1塔罗贴, 2 普通帖
    /// </summary>
    public int PostType { get; set; }
    /// <summary>
    /// 帖子状态
    /// </summary>
    public int PostState { get; set; }
    public string IP { get; set; }

    /// <summary>
    /// 用作"顶", 或者"标记"
    /// </summary>
    public int Mark { get; set; }
    public int Down { get; set; }

    /// <summary>
    /// 总参与人数. 回帖+顶+踩的总数
    /// </summary>
    public int AllTakePartIn { get; set; }
    /// <summary>
    /// 自定义标签
    /// </summary>
    public CustomerTag[] CustomerTags { get; set; }

    /// <summary>
    /// 塔罗牌
    /// </summary>
    public CardFormationInfo CardFormationInfo { get; set; }
    /// <summary>
    /// mongodb 用户信息
    /// </summary>
    public M_User m_User { get; set; }
}

public class M_User
{
    public int UserID { get; set; }
    public string NicName { get; set; }
    private string _AvatarURL;
    /// <summary>
    /// 头像
    /// </summary>
    public string AvatarURL
    {
        get
        {
            return _AvatarURL;
        }
        set { _AvatarURL = value; }
    }
}

public class CardFormationInfo
{
    public string CardFormationUrl { get; set; }
    public string CardFormationName { get; set; }
    public string CardFormationID { get; set; }
    public int W { get; set; }
    public int H { get; set; }
    public CardInfo[] CardInfos { get; set; }
}
public class CardInfo
{
    public string CardName { get; set; }

    public bool IsHandstand { get; set; }

    public string ImgUrl { get; set; }

    public bool IsPointCard { get; set; }

    public int X { get; set; }

    public int Y { get; set; }

    public int SortIndex { get; set; }

    public string Describe { get; set; }

    public int W { get; set; }

    public int H { get; set; }
}

public class Comment
{
    public ObjectId _id { get; set; }
    /// <summary>
    /// 冗余字段
    /// </summary>
    public string _idForString { get; set; }
    /// <summary>
    /// 冗余字段
    /// </summary>
    public int _Index { get; set; }
    /// <summary>
    /// 引用的外键id.
    /// </summary>
    public string FKid { get; set; }

    private string _Content;
    /// <summary>
    /// 回帖类型, 见枚举
    /// </summary>
    public int FKType { get; set; }

    public string Content
    {
        get
        {
            return _Content;
        }
        set { _Content = value; }
    }

    /// <summary>
    /// 子评论
    /// </summary>
    public Comment[] Children { get; set; }

    /// <summary>
    /// 帖子状态
    /// </summary>
    public int PostState { get; set; }
    public string IP { get; set; }
    public DateTime PostTime { get; set; }

    public M_User m_User { get; set; }

    /// <summary>
    /// 评论级别. 现在就顶级评论和子级评论
    /// </summary>
    public int CommentLevel { get; set; }
}

public class CustomerTag
{
    public ObjectId _id { get; set; }
    public string TagName { get; set; }
    /// <summary>
    /// 人气
    /// </summary>
    public int PopularityCount { get; set; }
    public DateTime CreateTime { get; set; }
    public DateTime LastModifyTime { get; set; }
}]]></ProjectItem><ProjectItem Name="\scriptmain.cs">
<![CDATA[/*
   Microsoft SQL Server Integration Services Script Task
   Write scripts using Microsoft Visual C# 2008.
   The ScriptMain is the entry point class of the script.
*/

using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;
using MongoDB.Driver.Builders;
using MongoDB.Bson;

namespace ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj
{
    [System.AddIn.AddIn("ScriptMain", Version = "1.0", Publisher = "", Description = "")]
    public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
    {

        #region VSTA generated code
        enum ScriptResults
        {
            Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
            Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
        };
        #endregion

        /*
		The execution engine calls this method when the task executes.
		To access the object model, use the Dts property. Connections, variables, events,
		and logging features are available as members of the Dts property as shown in the following examples.

		To reference a variable, call Dts.Variables["MyCaseSensitiveVariableName"].Value;
		To post a log entry, call Dts.Log("This is my log text", 999, null);
		To fire an event, call Dts.Events.FireInformation(99, "test", "hit the help message", "", 0, true);

		To use the connections collection use something like the following:
		ConnectionManager cm = Dts.Connections.Add("OLEDB");
		cm.ConnectionString = "Data Source=localhost;Initial Catalog=AdventureWorks;Provider=SQLNCLI10;Integrated Security=SSPI;Auto Translate=False;";

		Before returning from this method, set the value of Dts.TaskResult to indicate success or failure.
		
		To open Help, press F1.
	*/

        public void Main()
        {
            var dt = Convert.ToDateTime(Dts.Variables["StartTime"].Value);
            var startTime = new DateTime(dt.Year, dt.Month, dt.Day);
            var endtime = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);

            ToFormation(BsonDateTime.Create(startTime), BsonDateTime.Create(endtime));
            ToComments(BsonDateTime.Create(startTime), BsonDateTime.Create(endtime));


            Dts.TaskResult = (int)ScriptResults.Success;
        }

        #region
        static string conn = "Data Source=.;Initial Catalog=Tarot;Persist Security Info=True;User ID=sa;Password=sa1234;timeout=240";
        /// <summary>
        ///  update Formation's Popularity in Sql server
        /// </summary>
        public void ToFormation(BsonDateTime startTime, BsonDateTime endtime)
        {
            var list = MongoDBHelper.GetAll<M_Post>("Posts7Days",
                                                MongoDB.Driver.Builders.Query.And(
                                                    Query.GTE("PostTime", startTime),
                                                    Query.LT("PostTime", endtime)
                                                )
                                                );
            foreach (var item in list)
            {
                if (item.PostType != 1) continue;

                SqlHelper.ExecuteNonQuery(conn, CommandType.Text, "update CardFormation set Popularity=Popularity+1 where CardFormationID=" + item.CardFormationInfo.CardFormationID);

                foreach (var tag in item.CustomerTags)
                {
                    MongoDBHelper.UpdateAll<CustomerTag>("CustomerTag", Query.EQ("TagName", tag.TagName), Update.Inc("PopularityCount", 1));
                }

            }

            MongoDBHelper.InsertAll<M_Post>("Posts", list);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startTime"></param>
        /// <param name="entTime"></param>
        public void ToComments(BsonDateTime startTime, BsonDateTime entTime)
        {
            var lst = MongoDBHelper.GetAll<Comment>("Comments7Days",
                                                                                MongoDB.Driver.Builders.Query.And(
                                                                                    Query.GTE("PostTime", startTime),
                                                                                    Query.LT("PostTime", entTime)
                                                                                )
                                                                              );
            MongoDBHelper.InsertAll<Comment>("Comments",
                                                lst
                                                );
        }

        #endregion

    }
}]]></ProjectItem><ProjectItem Name="\sql.cs">
<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Collections;
using System.Data;
using System.Xml;

/// <summary>
/// The SqlHelper class is intended to encapsulate high performance, scalable best practices for 
/// common uses of SqlClient
/// </summary>
public sealed class SqlHelper
{
    #region private utility methods & constructors

    // Since this class provides only static methods, make the default constructor private to prevent 
    // instances from being created with "new SqlHelper()"
    private SqlHelper() { }

    /// <summary>
    /// This method is used to attach array of SqlParameters to a SqlCommand.
    /// 
    /// This method will assign a value of DbNull to any parameter with a direction of
    /// InputOutput and a value of null.  
    /// 
    /// This behavior will prevent default values from being used, but
    /// this will be the less common case than an intended pure output parameter (derived as InputOutput)
    /// where the user provided no input value.
    /// </summary>
    /// <param name="command">The command to which the parameters will be added</param>
    /// <param name="commandParameters">An array of SqlParameters to be added to command</param>
    private static void AttachParameters(SqlCommand command, SqlParameter[] commandParameters)
    {
        if (command == null) throw new ArgumentNullException("command");
        if (commandParameters != null)
        {
            foreach (SqlParameter p in commandParameters)
            {
                if (p != null)
                {
                    // Check for derived output value with no value assigned
                    if ((p.Direction == ParameterDirection.InputOutput ||
                        p.Direction == ParameterDirection.Input) &&
                        (p.Value == null))
                    {
                        p.Value = DBNull.Value;
                    }
                    command.Parameters.Add(p);
                }
            }
        }
    }

    /// <summary>
    /// This method assigns dataRow column values to an array of SqlParameters
    /// </summary>
    /// <param name="commandParameters">Array of SqlParameters to be assigned values</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
    private static void AssignParameterValues(SqlParameter[] commandParameters, DataRow dataRow)
    {
        if ((commandParameters == null) || (dataRow == null))
        {
            // Do nothing if we get no data
            return;
        }

        int i = 0;
        // Set the parameters values
        foreach (SqlParameter commandParameter in commandParameters)
        {
            // Check the parameter name
            if (commandParameter.ParameterName == null ||
                commandParameter.ParameterName.Length <= 1)
                throw new Exception(
                    string.Format(
                        "Please provide a valid parameter name on the parameter #{0}, the ParameterName property has the following value: '{1}'.",
                        i, commandParameter.ParameterName));
            if (dataRow.Table.Columns.IndexOf(commandParameter.ParameterName.Substring(1)) != -1)
                commandParameter.Value = dataRow[commandParameter.ParameterName.Substring(1)];
            i++;
        }
    }

    /// <summary>
    /// This method assigns an array of values to an array of SqlParameters
    /// </summary>
    /// <param name="commandParameters">Array of SqlParameters to be assigned values</param>
    /// <param name="parameterValues">Array of objects holding the values to be assigned</param>
    private static void AssignParameterValues(SqlParameter[] commandParameters, object[] parameterValues)
    {
        if ((commandParameters == null) || (parameterValues == null))
        {
            // Do nothing if we get no data
            return;
        }

        // We must have the same number of values as we pave parameters to put them in
        if (commandParameters.Length != parameterValues.Length)
        {
            throw new ArgumentException("Parameter count does not match Parameter Value count.");
        }

        // Iterate through the SqlParameters, assigning the values from the corresponding position in the 
        // value array
        for (int i = 0, j = commandParameters.Length; i < j; i++)
        {
            // If the current array value derives from IDbDataParameter, then assign its Value property
            if (parameterValues[i] is IDbDataParameter)
            {
                IDbDataParameter paramInstance = (IDbDataParameter)parameterValues[i];
                if (paramInstance.Value == null)
                {
                    commandParameters[i].Value = DBNull.Value;
                }
                else
                {
                    commandParameters[i].Value = paramInstance.Value;
                }
            }
            else if (parameterValues[i] == null)
            {
                commandParameters[i].Value = DBNull.Value;
            }
            else
            {
                commandParameters[i].Value = parameterValues[i];
            }
        }
    }

    /// <summary>
    /// This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
    /// to the provided command
    /// </summary>
    /// <param name="command">The SqlCommand to be prepared</param>
    /// <param name="connection">A valid SqlConnection, on which to execute this command</param>
    /// <param name="transaction">A valid SqlTransaction, or 'null'</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
    /// <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
    private static void PrepareCommand(SqlCommand command, SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters, out bool mustCloseConnection)
    {
        if (command == null) throw new ArgumentNullException("command");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        // If the provided connection is not open, we will open it
        if (connection.State != ConnectionState.Open)
        {
            mustCloseConnection = true;
            connection.Open();
        }
        else
        {
            mustCloseConnection = false;
        }

        // Associate the connection with the command
        command.Connection = connection;

        // Set the command text (stored procedure name or SQL statement)
        command.CommandText = commandText;

        // If we were provided a transaction, assign it
        if (transaction != null)
        {
            if (transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
            command.Transaction = transaction;
        }

        // Set the command type
        command.CommandType = commandType;

        // Attach the command parameters if they are provided
        if (commandParameters != null)
        {
            AttachParameters(command, commandParameters);
        }
        return;
    }

    #endregion private utility methods & constructors

    #region ExecuteNonQuery

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the database specified in 
    /// the connection string
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the database specified in the connection string 
    /// using the provided parameters
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteNonQuery(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored prcedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Finally, execute the command
        int retval = cmd.ExecuteNonQuery();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        if (mustCloseConnection)
            connection.Close();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteNonQuery(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns no resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Finally, execute the command
        int retval = cmd.ExecuteNonQuery();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQuery(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteNonQuery

    #region ExecuteDataset

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteDataset(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(connString, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter da = new SqlDataAdapter(cmd))
        {
            DataSet ds = new DataSet();

            // Fill the DataSet using default values for DataTable names, etc
            da.Fill(ds);

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            if (mustCloseConnection)
                connection.Close();

            // Return the dataset
            return ds;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteDataset(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter da = new SqlDataAdapter(cmd))
        {
            DataSet ds = new DataSet();

            // Fill the DataSet using default values for DataTable names, etc
            da.Fill(ds);

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            // Return the dataset
            return ds;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  DataSet ds = ExecuteDataset(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDataset(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteDataset(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteDataset(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteDataset

    #region ExecuteReader

    /// <summary>
    /// This enum is used to indicate whether the connection was provided by the caller, or created by SqlHelper, so that
    /// we can set the appropriate CommandBehavior when calling ExecuteReader()
    /// </summary>
    private enum SqlConnectionOwnership
    {
        /// <summary>Connection is owned and managed by SqlHelper</summary>
        Internal,
        /// <summary>Connection is owned and managed by the caller</summary>
        External
    }

    /// <summary>
    /// Create and prepare a SqlCommand, and call ExecuteReader with the appropriate CommandBehavior.
    /// </summary>
    /// <remarks>
    /// If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
    /// 
    /// If the caller provided the connection, we want to leave it to them to manage.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection, on which to execute this command</param>
    /// <param name="transaction">A valid SqlTransaction, or 'null'</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
    /// <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by SqlHelper</param>
    /// <returns>SqlDataReader containing the results of the command</returns>
    private static SqlDataReader ExecuteReader(SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters, SqlConnectionOwnership connectionOwnership)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        bool mustCloseConnection = false;
        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        try
        {
            PrepareCommand(cmd, connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

            // Create a reader
            SqlDataReader dataReader;

            // Call ExecuteReader with the appropriate CommandBehavior
            if (connectionOwnership == SqlConnectionOwnership.External)
            {
                dataReader = cmd.ExecuteReader();
            }
            else
            {
                dataReader = cmd.ExecuteReader(CommandBehavior.CloseConnection);
            }

            // Detach the SqlParameters from the command object, so they can be used again.
            // HACK: There is a problem here, the output parameter values are fletched 
            // when the reader is closed, so if the parameters are detached from the command
            // then the SqlReader can磘 set its values. 
            // When this happen, the parameters can磘 be used again in other command.
            bool canClear = true;
            foreach (SqlParameter commandParameter in cmd.Parameters)
            {
                if (commandParameter.Direction != ParameterDirection.Input)
                    canClear = false;
            }

            if (canClear)
            {
                cmd.Parameters.Clear();
            }

            return dataReader;
        }
        catch
        {
            if (mustCloseConnection)
                connection.Close();
            throw;
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        SqlConnection connection = null;
        try
        {
            connection = new SqlConnection(connectionString);
            connection.Open();

            // Call the private overload that takes an internally owned connection in place of the connection string
            return ExecuteReader(connection, null, commandType, commandText, commandParameters, SqlConnectionOwnership.Internal);
        }
        catch
        {
            // If we fail to return the SqlDatReader, we need to close the connection ourselves
            if (connection != null) connection.Close();
            throw;
        }

    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        // Pass through the call to the private overload using a null transaction value and an externally owned connection
        return ExecuteReader(connection, (SqlTransaction)null, commandType, commandText, commandParameters, SqlConnectionOwnership.External);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteReader(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///   SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Pass through to private overload, indicating that the connection is owned by the caller
        return ExecuteReader(transaction.Connection, transaction, commandType, commandText, commandParameters, SqlConnectionOwnership.External);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  SqlDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReader(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            AssignParameterValues(commandParameters, parameterValues);

            return ExecuteReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteReader(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteReader

    #region ExecuteScalar

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(connectionString, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            return ExecuteScalar(connection, commandType, commandText, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(string connectionString, string spName, params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();

        bool mustCloseConnection = false;
        PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

        // Execute the command & return the results
        object retval = cmd.ExecuteScalar();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();

        if (mustCloseConnection)
            connection.Close();

        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(conn, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteScalar(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a 1x1 resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Execute the command & return the results
        object retval = cmd.ExecuteScalar();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  int orderCount = (int)ExecuteScalar(trans, "GetOrderCount", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalar(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // PPull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteScalar(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteScalar(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteScalar

    #region ExecuteXmlReader
    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteXmlReader(connection, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");

        bool mustCloseConnection = false;
        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        try
        {
            PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters, out mustCloseConnection);

            // Create the DataAdapter & DataSet
            XmlReader retval = cmd.ExecuteXmlReader();

            // Detach the SqlParameters from the command object, so they can be used again
            cmd.Parameters.Clear();

            return retval;
        }
        catch
        {
            if (mustCloseConnection)
                connection.Close();
            throw;
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(conn, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure using "FOR XML AUTO"</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlConnection connection, string spName, params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteXmlReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteXmlReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, CommandType.StoredProcedure, "GetOrders");
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, CommandType commandType, string commandText)
    {
        // Pass through the call providing null for the set of SqlParameters
        return ExecuteXmlReader(transaction, commandType, commandText, (SqlParameter[])null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command using "FOR XML AUTO"</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");

        // Create a command and prepare it for execution
        SqlCommand cmd = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        XmlReader retval = cmd.ExecuteXmlReader();

        // Detach the SqlParameters from the command object, so they can be used again
        cmd.Parameters.Clear();
        return retval;
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  XmlReader r = ExecuteXmlReader(trans, "GetOrders", 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReader(SqlTransaction transaction, string spName, params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            return ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            return ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion ExecuteXmlReader

    #region FillDataset
    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
    /// the connection string. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)</param>
    public static void FillDataset(string connectionString, CommandType commandType, string commandText, DataSet dataSet, string[] tableNames)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");

        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, commandType, commandText, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    public static void FillDataset(string connectionString, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, commandType, commandText, dataSet, tableNames, commandParameters);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, 24);
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>    
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(string connectionString, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        // Create & open a SqlConnection, and dispose of it after we are done
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            connection.Open();

            // Call the overload that takes a connection in place of the connection string
            FillDataset(connection, spName, dataSet, tableNames, parameterValues);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>    
    public static void FillDataset(SqlConnection connection, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames)
    {
        FillDataset(connection, commandType, commandText, dataSet, tableNames, null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    public static void FillDataset(SqlConnection connection, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        FillDataset(connection, null, commandType, commandText, dataSet, tableNames, commandParameters);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(conn, "GetOrders", ds, new string[] {"orders"}, 24, 36);
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(SqlConnection connection, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            FillDataset(connection, CommandType.StoredProcedure, spName, dataSet, tableNames, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            FillDataset(connection, CommandType.StoredProcedure, spName, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    public static void FillDataset(SqlTransaction transaction, CommandType commandType,
        string commandText,
        DataSet dataSet, string[] tableNames)
    {
        FillDataset(transaction, commandType, commandText, dataSet, tableNames, null);
    }

    /// <summary>
    /// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    public static void FillDataset(SqlTransaction transaction, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        FillDataset(transaction.Connection, transaction, commandType, commandText, dataSet, tableNames, commandParameters);
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified 
    /// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <remarks>
    /// This method provides no access to output parameters or the stored procedure's return value parameter.
    /// 
    /// e.g.:  
    ///  FillDataset(trans, "GetOrders", ds, new string[]{"orders"}, 24, 36);
    /// </remarks>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
    public static void FillDataset(SqlTransaction transaction, string spName,
        DataSet dataSet, string[] tableNames,
        params object[] parameterValues)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (dataSet == null) throw new ArgumentNullException("dataSet");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If we receive parameter values, we need to figure out where they go
        if ((parameterValues != null) && (parameterValues.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Assign the provided values to these parameters based on parameter order
            AssignParameterValues(commandParameters, parameterValues);

            // Call the overload that takes an array of SqlParameters
            FillDataset(transaction, CommandType.StoredProcedure, spName, dataSet, tableNames, commandParameters);
        }
        else
        {
            // Otherwise we can just call the SP without params
            FillDataset(transaction, CommandType.StoredProcedure, spName, dataSet, tableNames);
        }
    }

    /// <summary>
    /// Private helper method that execute a SqlCommand (that returns a resultset) against the specified SqlTransaction and SqlConnection
    /// using the provided parameters.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  FillDataset(conn, trans, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, new SqlParameter("@prodid", 24));
    /// </remarks>
    /// <param name="connection">A valid SqlConnection</param>
    /// <param name="transaction">A valid SqlTransaction</param>
    /// <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
    /// <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
    /// by a user defined name (probably the actual table name)
    /// </param>
    /// <param name="commandParameters">An array of SqlParamters used to execute the command</param>
    private static void FillDataset(SqlConnection connection, SqlTransaction transaction, CommandType commandType,
        string commandText, DataSet dataSet, string[] tableNames,
        params SqlParameter[] commandParameters)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (dataSet == null) throw new ArgumentNullException("dataSet");

        // Create a command and prepare it for execution
        SqlCommand command = new SqlCommand();
        bool mustCloseConnection = false;
        PrepareCommand(command, connection, transaction, commandType, commandText, commandParameters, out mustCloseConnection);

        // Create the DataAdapter & DataSet
        using (SqlDataAdapter dataAdapter = new SqlDataAdapter(command))
        {

            // Add the table mappings specified by the user
            if (tableNames != null && tableNames.Length > 0)
            {
                string tableName = "Table";
                for (int index = 0; index < tableNames.Length; index++)
                {
                    if (tableNames[index] == null || tableNames[index].Length == 0) throw new ArgumentException("The tableNames parameter must contain a list of tables, a value was provided as null or empty string.", "tableNames");
                    dataAdapter.TableMappings.Add(tableName, tableNames[index]);
                    tableName += (index + 1).ToString();
                }
            }

            // Fill the DataSet using default values for DataTable names, etc
            dataAdapter.Fill(dataSet);

            // Detach the SqlParameters from the command object, so they can be used again
            command.Parameters.Clear();
        }

        if (mustCloseConnection)
            connection.Close();
    }
    #endregion

    #region UpdateDataset
    /// <summary>
    /// Executes the respective command for each inserted, updated, or deleted row in the DataSet.
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  UpdateDataset(conn, insertCommand, deleteCommand, updateCommand, dataSet, "Order");
    /// </remarks>
    /// <param name="insertCommand">A valid transact-SQL statement or stored procedure to insert new records into the data source</param>
    /// <param name="deleteCommand">A valid transact-SQL statement or stored procedure to delete records from the data source</param>
    /// <param name="updateCommand">A valid transact-SQL statement or stored procedure used to update records in the data source</param>
    /// <param name="dataSet">The DataSet used to update the data source</param>
    /// <param name="tableName">The DataTable used to update the data source.</param>
    public static void UpdateDataset(SqlCommand insertCommand, SqlCommand deleteCommand, SqlCommand updateCommand, DataSet dataSet, string tableName)
    {
        if (insertCommand == null) throw new ArgumentNullException("insertCommand");
        if (deleteCommand == null) throw new ArgumentNullException("deleteCommand");
        if (updateCommand == null) throw new ArgumentNullException("updateCommand");
        if (tableName == null || tableName.Length == 0) throw new ArgumentNullException("tableName");

        // Create a SqlDataAdapter, and dispose of it after we are done
        using (SqlDataAdapter dataAdapter = new SqlDataAdapter())
        {
            // Set the data adapter commands
            dataAdapter.UpdateCommand = updateCommand;
            dataAdapter.InsertCommand = insertCommand;
            dataAdapter.DeleteCommand = deleteCommand;

            // Update the dataset changes in the data source
            dataAdapter.Update(dataSet, tableName);

            // Commit all the changes made to the DataSet
            dataSet.AcceptChanges();
        }
    }
    #endregion

    #region CreateCommand
    /// <summary>
    /// Simplify the creation of a Sql command object by allowing
    /// a stored procedure and optional parameters to be provided
    /// </summary>
    /// <remarks>
    /// e.g.:  
    ///  SqlCommand command = CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
    /// <returns>A valid SqlCommand object</returns>
    public static SqlCommand CreateCommand(SqlConnection connection, string spName, params string[] sourceColumns)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // Create a SqlCommand
        SqlCommand cmd = new SqlCommand(spName, connection);
        cmd.CommandType = CommandType.StoredProcedure;

        // If we receive parameter values, we need to figure out where they go
        if ((sourceColumns != null) && (sourceColumns.Length > 0))
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Assign the provided source columns to these parameters based on parameter order
            for (int index = 0; index < sourceColumns.Length; index++)
                commandParameters[index].SourceColumn = sourceColumns[index];

            // Attach the discovered parameters to the SqlCommand object
            AttachParameters(cmd, commandParameters);
        }

        return cmd;
    }
    #endregion

    #region ExecuteNonQueryTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.  
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified
    /// SqlTransaction using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An int representing the number of rows affected by the command</returns>
    public static int ExecuteNonQueryTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // Sf the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteDatasetTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(string connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        //If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the store procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on row values.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A dataset containing the resultset generated by the command</returns>
    public static DataSet ExecuteDatasetTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteDataset(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteDataset(transaction, CommandType.StoredProcedure, spName);
        }
    }

    #endregion

    #region ExecuteReaderTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(connectionString, CommandType.StoredProcedure, spName);
        }
    }


    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>A SqlDataReader containing the resultset generated by the command</returns>
    public static SqlDataReader ExecuteReaderTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteReader(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteScalarTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the database specified in 
    /// the connection string using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(String connectionString, String spName, DataRow dataRow)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(connectionString, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(connectionString, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a 1x1 resultset) against the specified SqlTransaction
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
    public static object ExecuteScalarTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion

    #region ExecuteXmlReaderTypedParams
    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReaderTypedParams(SqlConnection connection, String spName, DataRow dataRow)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteXmlReader(connection, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteXmlReader(connection, CommandType.StoredProcedure, spName);
        }
    }

    /// <summary>
    /// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlTransaction 
    /// using the dataRow column values as the stored procedure's parameters values.
    /// This method will query the database to discover the parameters for the 
    /// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
    /// </summary>
    /// <param name="transaction">A valid SqlTransaction object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
    /// <returns>An XmlReader containing the resultset generated by the command</returns>
    public static XmlReader ExecuteXmlReaderTypedParams(SqlTransaction transaction, String spName, DataRow dataRow)
    {
        if (transaction == null) throw new ArgumentNullException("transaction");
        if (transaction != null && transaction.Connection == null) throw new ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        // If the row has values, the store procedure parameters must be initialized
        if (dataRow != null && dataRow.ItemArray.Length > 0)
        {
            // Pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
            SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection, spName);

            // Set the parameters values
            AssignParameterValues(commandParameters, dataRow);

            return SqlHelper.ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
        }
        else
        {
            return SqlHelper.ExecuteXmlReader(transaction, CommandType.StoredProcedure, spName);
        }
    }
    #endregion


    #region 实用方法
    public static string SecLike(string like, bool preMatch, bool lastMatch)
    {
        if (!string.IsNullOrEmpty(like))
        {
            like = like.Replace("[", "[[]").Replace("%", "[%]");
        }
        else
        {
            like = "";
        }
        if (preMatch) like = "%" + like;
        like.TrimEnd('%');
        if (lastMatch) like += "%";
        return like;
    }

    public static DateTime? SecDate(DateTime date, bool nullable)
    {
        if (date < DateTime.Parse("1/1/1753 12:00:00 AM ")) return nullable ? null : new DateTime?(DateTime.Parse("1/1/1753 12:00:00 AM "));
        if (date > DateTime.Parse("12/31/9999 11:59:59 PM")) return nullable ? null : new DateTime?(DateTime.Parse("12/31/9999 11:59:59 PM"));
        return new DateTime?(date);
    }

    public static int? SecInt(int value, bool nullable)
    {
        if (value < -2147483648) return nullable ? null : new int?((-2147483648));
        if (value > 2147483647) return nullable ? null : new int?(2147483647);
        return new int?(value);
    }

    public static int SecIntMax(int? value)
    {
        if (value == null || value == 0)
        {
            return 2147483647;
        }
        else return value.Value;
    }

    public static int SecIntMin(int? value)
    {
        if (value == null)
        {
            return 0;
        }
        else return value.Value;
    }
    #endregion

}

/// <summary>
/// SqlHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
/// ability to discover parameters for stored procedures at run-time.
/// </summary>
public sealed class SqlHelperParameterCache
{
    #region private methods, variables, and constructors

    //Since this class provides only static methods, make the default constructor private to prevent 
    //instances from being created with "new SqlHelperParameterCache()"
    private SqlHelperParameterCache() { }

    private static Hashtable paramCache = Hashtable.Synchronized(new Hashtable());

    /// <summary>
    /// Resolve at run time the appropriate set of SqlParameters for a stored procedure
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
    /// <returns>The parameter array discovered.</returns>
    private static SqlParameter[] DiscoverSpParameterSet(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        SqlCommand cmd = new SqlCommand(spName, connection);
        cmd.CommandType = CommandType.StoredProcedure;

        connection.Open();
        SqlCommandBuilder.DeriveParameters(cmd);
        connection.Close();

        if (!includeReturnValueParameter)
        {
            cmd.Parameters.RemoveAt(0);
        }

        SqlParameter[] discoveredParameters = new SqlParameter[cmd.Parameters.Count];

        cmd.Parameters.CopyTo(discoveredParameters, 0);

        // Init the parameters with a DBNull value
        foreach (SqlParameter discoveredParameter in discoveredParameters)
        {
            discoveredParameter.Value = DBNull.Value;
        }
        return discoveredParameters;
    }

    /// <summary>
    /// Deep copy of cached SqlParameter array
    /// </summary>
    /// <param name="originalParameters"></param>
    /// <returns></returns>
    private static SqlParameter[] CloneParameters(SqlParameter[] originalParameters)
    {
        SqlParameter[] clonedParameters = new SqlParameter[originalParameters.Length];

        for (int i = 0, j = originalParameters.Length; i < j; i++)
        {
            clonedParameters[i] = (SqlParameter)((ICloneable)originalParameters[i]).Clone();
        }

        return clonedParameters;
    }

    #endregion private methods, variables, and constructors

    #region caching functions

    /// <summary>
    /// Add parameter array to the cache
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <param name="commandParameters">An array of SqlParamters to be cached</param>
    public static void CacheParameterSet(string connectionString, string commandText, params SqlParameter[] commandParameters)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        string hashKey = connectionString + ":" + commandText;

        paramCache[hashKey] = commandParameters;
    }

    /// <summary>
    /// Retrieve a parameter array from the cache
    /// </summary>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="commandText">The stored procedure name or T-SQL command</param>
    /// <returns>An array of SqlParamters</returns>
    public static SqlParameter[] GetCachedParameterSet(string connectionString, string commandText)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (commandText == null || commandText.Length == 0) throw new ArgumentNullException("commandText");

        string hashKey = connectionString + ":" + commandText;

        SqlParameter[] cachedParameters = paramCache[hashKey] as SqlParameter[];
        if (cachedParameters == null)
        {
            return null;
        }
        else
        {
            return CloneParameters(cachedParameters);
        }
    }

    #endregion caching functions

    #region Parameter Discovery Functions

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <returns>An array of SqlParameters</returns>
    public static SqlParameter[] GetSpParameterSet(string connectionString, string spName)
    {
        return GetSpParameterSet(connectionString, spName, false);
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connectionString">A valid connection string for a SqlConnection</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    public static SqlParameter[] GetSpParameterSet(string connectionString, string spName, bool includeReturnValueParameter)
    {
        if (connectionString == null || connectionString.Length == 0) throw new ArgumentNullException("connectionString");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            return GetSpParameterSetInternal(connection, spName, includeReturnValueParameter);
        }
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <returns>An array of SqlParameters</returns>
    internal static SqlParameter[] GetSpParameterSet(SqlConnection connection, string spName)
    {
        return GetSpParameterSet(connection, spName, false);
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <remarks>
    /// This method will query the database for this information, and then store it in a cache for future requests.
    /// </remarks>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    internal static SqlParameter[] GetSpParameterSet(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        using (SqlConnection clonedConnection = (SqlConnection)((ICloneable)connection).Clone())
        {
            return GetSpParameterSetInternal(clonedConnection, spName, includeReturnValueParameter);
        }
    }

    /// <summary>
    /// Retrieves the set of SqlParameters appropriate for the stored procedure
    /// </summary>
    /// <param name="connection">A valid SqlConnection object</param>
    /// <param name="spName">The name of the stored procedure</param>
    /// <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
    /// <returns>An array of SqlParameters</returns>
    private static SqlParameter[] GetSpParameterSetInternal(SqlConnection connection, string spName, bool includeReturnValueParameter)
    {
        if (connection == null) throw new ArgumentNullException("connection");
        if (spName == null || spName.Length == 0) throw new ArgumentNullException("spName");

        string hashKey = connection.ConnectionString + ":" + spName + (includeReturnValueParameter ? ":include ReturnValue Parameter" : "");

        SqlParameter[] cachedParameters;

        cachedParameters = paramCache[hashKey] as SqlParameter[];
        if (cachedParameters == null)
        {
            SqlParameter[] spParameters = DiscoverSpParameterSet(connection, spName, includeReturnValueParameter);
            paramCache[hashKey] = spParameters;
            cachedParameters = spParameters;
        }

        return CloneParameters(cachedParameters);
    }

    #endregion Parameter Discovery Functions

}]]></ProjectItem><ProjectItem Name="\properties\resources.designer.cs">
<![CDATA[//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Resources.get_ResourceManager():System.Resources.Resou" +
    "rceManager")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Resources.get_Culture():System.Globalization.CultureIn" +
    "fo")]
[assembly: global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Resources.set_Culture(System.Globalization.CultureInfo" +
    "):Void")]

namespace ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}]]></ProjectItem><ProjectItem Name="\mongo.cs">
<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MongoDB.Driver;
using MongoDB.Bson;
using MongoDB.Driver.Builders;


/// <summary>
/// mongodb的封装类。
/// add by yancong2008@gmail.com 2011.05.14
/// </summary>
public class PagerInfo
{
    int _Page = 1;//当前页
    int _PageSize = 10;
    public int Page { get { return _Page; } set { _Page = value; } }
    public int PageSize { get { return _PageSize; } set { _PageSize = value; } }
}

public sealed class MongoDBHelper
//public sealed class MongoDBHelper<T>
//where T :class
{

    public static readonly string connectionString_Default = "Server=127.0.0.1"; // System.Configuration.ConfigurationManager.AppSettings["ConnectionString_mongoDB"];
    public static readonly string database_Default = "Tarot";

    #region 新增

    public static SafeModeResult InsertOne<T>(string collectionName, T entity)
    {
        return MongoDBHelper.InsertOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entity);
    }

    public static SafeModeResult InsertOne<T>(string connectionString, string databaseName, string collectionName, T entity)
    {
        SafeModeResult result = new SafeModeResult();

        if (null == entity)
        {
            return null;
        }

        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);



        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
            result = myCollection.Insert(entity);
        }

        return result;
    }

    public static IEnumerable<SafeModeResult> InsertAll<T>(string collectionName, IEnumerable<T> entitys)
    {
        return MongoDBHelper.InsertAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entitys);
    }

    public static IEnumerable<SafeModeResult> InsertAll<T>(string connectionString, string databaseName, string collectionName, IEnumerable<T> entitys)
    {
        IEnumerable<SafeModeResult> result = null;

        if (null == entitys)
        {
            return null;
        }

        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);



        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
            result = myCollection.InsertBatch(entitys);
        }

        return result;
    }

    #endregion


    #region 修改

    public static SafeModeResult UpdateOne<T>(string collectionName, T entity)
    {
        return MongoDBHelper.UpdateOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, entity);
    }

    public static SafeModeResult UpdateOne<T>(string connectionString, string databaseName, string collectionName, T entity)
    {
        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        SafeModeResult result;

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            result = myCollection.Save(entity);

        }

        return result;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="update">更新设置。调用示例：Update.Set("Title", "yanc") 或者 Update.Set("Title", "yanc").Set("Author", "yanc2") 等等</param>
    /// <returns></returns>
    public static SafeModeResult UpdateAll<T>(string collectionName, IMongoQuery query, IMongoUpdate update)
    {
        return MongoDBHelper.UpdateAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, update);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="connectionString"></param>
    /// <param name="databaseName"></param>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="update">更新设置。调用示例：Update.Set("Title", "yanc") 或者 Update.Set("Title", "yanc").Set("Author", "yanc2") 等等</param>
    /// <returns></returns>
    public static SafeModeResult UpdateAll<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query, IMongoUpdate update)
    {
        SafeModeResult result;

        if (null == query || null == update)
        {
            return null;
        }


        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            result = myCollection.Update(query, update, UpdateFlags.Multi);
        }

        return result;
    }

    #endregion


    #region 删除

    public static SafeModeResult Delete(string collectionName, string _id)
    {
        return MongoDBHelper.Delete(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, _id);
    }

    public static SafeModeResult Delete(string connectionString, string databaseName, string collectionName, string _id)
    {
        SafeModeResult result;
        ObjectId id;
        if (!ObjectId.TryParse(_id, out id))
        {
            return null;
        }



        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);



        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            result = myCollection.Remove(Query.EQ("_id", id));
        }

        return result;

    }

    public static SafeModeResult DeleteAll(string collectionName)
    {
        return MongoDBHelper.DeleteAll(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, null);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <returns></returns>
    public static SafeModeResult DeleteAll(string collectionName, IMongoQuery query)
    {
        return MongoDBHelper.DeleteAll(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="connectionString"></param>
    /// <param name="databaseName"></param>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <returns></returns>
    public static SafeModeResult DeleteAll(string connectionString, string databaseName, string collectionName, IMongoQuery query)
    {
        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        SafeModeResult result;

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            if (null == query)
            {
                result = myCollection.RemoveAll();
            }
            else
            {
                result = myCollection.Remove(query);
            }
        }

        return result;

    }

    #endregion


    #region 获取单条信息

    public static T GetOne<T>(string collectionName, string _id)
    {
        return MongoDBHelper.GetOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, _id);
    }

    public static T GetOne<T>(string connectionString, string databaseName, string collectionName, string _id)
    {
        T result = default(T);
        ObjectId id;
        if (!ObjectId.TryParse(_id, out id))
        {
            return default(T);
        }

        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);



        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);


            result = myCollection.FindOneAs<T>(Query.EQ("_id", id));
        }

        return result;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <returns></returns>
    public static T GetOne<T>(string collectionName, IMongoQuery query)
    {
        return GetOne<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="connectionString"></param>
    /// <param name="databaseName"></param>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <returns></returns>
    public static T GetOne<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query)
    {
        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        T result = default(T);

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            if (null == query)
            {
                result = myCollection.FindOneAs<T>();
            }
            else
            {
                result = myCollection.FindOneAs<T>(query);
            }
        }

        return result;
    }
    public static bool Exists(string collectionName, IMongoQuery query)
    {
        return Count(collectionName, query) > 0;
    }

    public static int Count(string collectionName, IMongoQuery query)
    {
        MongoServer server = MongoServer.Create(connectionString_Default);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(database_Default);

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            return (int)myCollection.Count(query);
        }
    }
    #endregion


    #region 获取多个

    public static List<T> GetAll<T>(string collectionName, MongoDB.Driver.IMongoQuery query)
    {
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query);
    }

    /// <summary>
    /// 如果不清楚具体的数量，一般不要用这个函数。
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string connectionString, string databaseName, string collectionName, MongoDB.Driver.IMongoQuery query)
    {
        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        List<T> result = new List<T>();

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            foreach (T entity in myCollection.FindAs<T>(query))
            {
                result.Add(entity);
            }
        }

        return result;
    }

    public static List<T> GetAll<T>(string collectionName, int count)
    {
        return MongoDBHelper.GetAll<T>(collectionName, count, null, null);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="count"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, int count, IMongoQuery query)
    {
        return MongoDBHelper.GetAll<T>(collectionName, count, query, null);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="count"></param>
    /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, int count, IMongoSortBy sortBy)
    {
        return MongoDBHelper.GetAll<T>(collectionName, count, null, sortBy);
    }

    /// <summary>

    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="count"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
    /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, int count, IMongoQuery query, IMongoSortBy sortBy, params string[] fields)
    {
        PagerInfo pagerInfo = new PagerInfo();
        pagerInfo.Page = 1;
        pagerInfo.PageSize = count;
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy, fields);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="pagerInfo"></param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo)
    {
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, null);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="pagerInfo"></param>
    /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy)
    {
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="pagerInfo"></param>
    /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, params string[] fields)
    {
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, null, fields);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="pagerInfo"></param>
    /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
    /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy, params string[] fields)
    {
        return MongoDBHelper.GetAll<T>(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, query, pagerInfo, sortBy, fields);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="connectionString"></param>
    /// <param name="databaseName"></param>
    /// <param name="collectionName"></param>
    /// <param name="query">条件查询。 调用示例：Query.Matches("Title", "感冒") 或者 Query.EQ("Title", "感冒") 或者Query.And(Query.Matches("Title", "感冒"),Query.EQ("Author", "yanc")) 等等</param>
    /// <param name="pagerInfo"></param>
    /// <param name="sortBy">排序用的。调用示例：SortBy.Descending("Title") 或者 SortBy.Descending("Title").Ascending("Author")等等</param>
    /// <param name="fields">只返回所需要的字段的数据。调用示例："Title" 或者 new string[] { "Title", "Author" }等等</param>
    /// <returns></returns>
    public static List<T> GetAll<T>(string connectionString, string databaseName, string collectionName, IMongoQuery query, PagerInfo pagerInfo, IMongoSortBy sortBy, params string[] fields)
    {
        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);

        List<T> result = new List<T>();

        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);

            MongoCursor<T> myCursor;

            if (null == query)
            {
                myCursor = myCollection.FindAllAs<T>();
            }
            else
            {
                myCursor = myCollection.FindAs<T>(query);
            }

            if (null != sortBy)
            {
                myCursor.SetSortOrder(sortBy);
            }

            if (null != fields)
            {
                myCursor.SetFields(fields);
            }

            foreach (T entity in myCursor.SetSkip((pagerInfo.Page - 1) * pagerInfo.PageSize).SetLimit(pagerInfo.PageSize))//.SetSkip(100).SetLimit(10)是指读取第一百条后的10条数据。
            {
                result.Add(entity);
            }


        }

        return result;
    }

    #endregion


    #region 索引
    public static void CreateIndex(string collectionName, params string[] keyNames)
    {
        MongoDBHelper.CreateIndex(MongoDBHelper.connectionString_Default, MongoDBHelper.database_Default, collectionName, keyNames);
    }

    public static void CreateIndex(string connectionString, string databaseName, string collectionName, params string[] keyNames)
    {
        SafeModeResult result = new SafeModeResult();

        if (null == keyNames)
        {
            return;
        }

        MongoServer server = MongoServer.Create(connectionString);

        //获取数据库或者创建数据库（不存在的话）。
        MongoDatabase database = server.GetDatabase(databaseName);



        using (server.RequestStart(database))//开始连接数据库。
        {
            MongoCollection<BsonDocument> myCollection = database.GetCollection<BsonDocument>(collectionName);
            if (!myCollection.IndexExists(keyNames))
            {
                myCollection.EnsureIndex(keyNames);
            }
        }

    }
    #endregion




}]]></ProjectItem><ProjectItem Name="\st_26f00f5f5cb84de6a4ad88a38c37f72c.csproj">
<![CDATA[<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This section defines project-level properties.

       Configuration - Specifies whether the default configuration is Release or Debug.
       Platform - Specifies what CPU the output of this project can run on.
       OutputType - Must be "Library" for VSTA.
       NoStandardLibraries - Set to "false" for VSTA.
       RootNamespace - In C#, this specifies the namespace given to new files.
                       In Visual Basic, all objects are wrapped in this namespace at runtime.
       AssemblyName - Name of the output assembly.
  -->
  <PropertyGroup>
    <ProjectTypeGuids>{A860303F-1F3F-4691-B57E-529FC101A107};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <OutputType>Library</OutputType>
    <NoStandardLibraries>false</NoStandardLibraries>
    <RootNamespace>ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj</RootNamespace>
    <AssemblyName>ST_26f00f5f5cb84de6a4ad88a38c37f72c.csproj</AssemblyName>
    <ProjectGuid>{5318AF9B-C25D-4C17-9FAE-4A8E1954FD15}</ProjectGuid>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Debug" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <DebugSymbols>true</DebugSymbols>
    <Optimize>false</Optimize>
    <OutputPath>.\bin\Debug\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section defines properties that are set when the "Release" configuration is
       selected.

       DebugSymbols - If true, create symbols (.pdb). If false, do not create symbols.
       Optimize - If true, optimize the build output. If false, do not optimize.
       OutputPath - Output path of the project relative to the project file.
       EnableUnmanagedDebugging - If true, starting the debugger will attach both managed and unmanaged debuggers.
       DefineConstants - Constants defined for the preprocessor.
       Warning Level - Warning level for the compiler.
  -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
    <OutputPath>.\bin\Release\</OutputPath>
    <EnableUnmanagedDebugging>false</EnableUnmanagedDebugging>
    <DefineConstants>TRACE</DefineConstants>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <!-- This section enables pre- and post-build steps. However,
       it is recommended that MSBuild tasks be used instead of these properties.
  -->
  <PropertyGroup>
    <PreBuildEvent>
    </PreBuildEvent>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- This sections specifies references for the project. -->
  <ItemGroup>
    <Reference Include="MongoDB.Bson, Version=1.3.1.4349, Culture=neutral, PublicKeyToken=f686731cfb9cc103, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>D:\work\Tarot\Tarot\packages\CSharpDriver-1.3.1.4349\MongoDB.Bson.dll</HintPath>
    </Reference>
    <Reference Include="MongoDB.Driver, Version=1.3.1.4349, Culture=neutral, PublicKeyToken=f686731cfb9cc103, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>D:\work\Tarot\Tarot\packages\CSharpDriver-1.3.1.4349\MongoDB.Driver.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.AddIn, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL" />
    <Reference Include="System.Core">
      <RequiredTargetFramework>3.5</RequiredTargetFramework>
    </Reference>
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.SqlServer.ManagedDTS, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
    <Reference Include="Microsoft.SqlServer.ScriptTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" />
  </ItemGroup>
  <!-- This section defines the user source files that are part of the
       project.

       Compile - Specifies a source file to compile.
       EmbeddedResource - Specifies a .resx file for embedded resources.
       None - Specifies a file that is not to be passed to the compiler (for instance,
              a text file or XML file).
       AppDesigner - Specifies the directory where the application properties files can
                     be found.
  -->
  <ItemGroup>
    <AppDesigner Include="Properties\" />
    <Compile Include="model.cs" />
    <Compile Include="Mongo.cs" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
    </Compile>
    <Compile Include="ScriptMain.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Sql.cs" />
    <!-- Include the default configuration information and metadata files for the add-in.
         These files are copied to the build output directory when the project is
         built, and the path to the configuration file is passed to add-in on the command
         line when debugging.
    -->
  </ItemGroup>
  <!-- Include the build rules for a C# project.-->
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- This section defines VSTA properties that describe the host-changable project properties. -->
  <ProjectExtensions>
    <VisualStudio>
      <FlavorProperties GUID="{A860303F-1F3F-4691-B57E-529FC101A107}">
        <ProjectProperties HostName="VSTAHostName" HostPackage="{C1B21C64-9E6F-4923-A89D-9F958503C1CE}" ApplicationType="usd" Language="cs" TemplatesPath="" DebugInfoExeName="#HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\InstallDir#\devenv.exe" />
        <Host Name="SSIS_ScriptTask" />
        <ProjectClient>
          <HostIdentifier>SSIS_ScriptTask</HostIdentifier>
        </ProjectClient>
      </FlavorProperties>
    </VisualStudio>
  </ProjectExtensions>
</Project>]]></ProjectItem><BinaryItem Name="\bin\release\st_26f00f5f5cb84de6a4ad88a38c37f72c.csproj.dll">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
eyAAAAQqIgIDfSAAAAQqHgJ7IQAABCoiAgN9IQAABCoeAigOAAAKKh4CeyMAAAQqIgIDfSMAAAQq
HgJ7JAAABCoiAgN9JAAABCoeAnsiAAAEKiICA30iAAAEKh4CKA4AAAoqHgJ7JQAABCoiAgN9JQAA
BCoeAnsmAAAEKiICA30mAAAEKh4CeycAAAQqIgIDfScAAAQqHgJ7KAAABCoiAgN9KAAABCoeAnsp
AAAEKiICA30pAAAEKh4CeyoAAAQqIgIDfSoAAAQqHgIoDgAACioeAnsrAAAEKiICA30rAAAEKh4C
eywAAAQqIgIDfSwAAAQqHgJ7LQAABCoiAgN9LQAABCoeAnsuAAAEKiICA30uAAAEKh4Cey8AAAQq
IgIDfS8AAAQqHgJ7MAAABCoiAgN9MAAABCoeAnsxAAAEKiICA30xAAAEKh4CezIAAAQqIgIDfTIA
AAQqHgJ7MwAABCoiAgN9MwAABCoeAns0AAAEKiICA300AAAEKh4CKA4AAAoqHgJ7NgAABCoiAgN9
NgAABCoeAns3AAAEKiICA303AAAEKh4CezgAAAQqIgIDfTgAAAQqHgJ7OQAABCoiAgN9OQAABCoe
Ans6AAAEKiICA306AAAEKh4CezUAAAQqIgIDfTUAAAQqHgJ7OwAABCoiAgN9OwAABCoeAns8AAAE
KiICA308AAAEKh4Cez0AAAQqIgIDfT0AAAQqHgJ7PgAABCoiAgN9PgAABCoeAns/AAAEKiICA30/
AAAEKh4Ce0AAAAQqIgIDfUAAAAQqHgIoDgAACioeAntBAAAEKiICA31BAAAEKh4Ce0IAAAQqIgID
fUIAAAQqHgJ7QwAABCoiAgN9QwAABCoeAntEAAAEKiICA31EAAAEKh4Ce0UAAAQqIgIDfUUAAAQq
HgIoDgAACioAAAAAtAAAAM7K774BAAAAkQAAAGxTeXN0ZW0uUmVzb3VyY2VzLlJlc291cmNlUmVh
ZGVyLCBtc2NvcmxpYiwgVmVyc2lvbj0yLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tl
eVRva2VuPWI3N2E1YzU2MTkzNGUwODkjU3lzdGVtLlJlc291cmNlcy5SdW50aW1lUmVzb3VyY2VT
ZXQCAAAAAAAAAAAAAABQQURQQURQtAAAAEJTSkIBAAEAAAAAAAwAAAB2Mi4wLjUwNzI3AAAAAAUA
bAAAAOwsAAAjfgAAWC0AAIAcAAAjU3RyaW5ncwAAAADYSQAAdAcAACNVUwBMUQAAEAAAACNHVUlE
AAAAXFEAALALAAAjQmxvYgAAAAAAAAACAAABVx2iCQkPAAAA+gEzABYAAAEAAABeAAAAEAAAAEUA
AAD/AAAAywEAAJcAAAAEAAAAzwAAACsAAAAJAAAAOwAAAHQAAAAJAAAAAQAAAAkAAAABAAAAAgAA
ABcAAAAWAAAAAAAKAAEAAAAAAAYAZAFdAQYAawFdAQoAuAGPAQ4A6QHUARIAKQITAhIANAITAhIA
UgIHAhIAcAITAhIAfgITAhIAjQIHAhIAuAIHAhIAzwITAhYABAP5AgYA0gNdAQYA3QNdAQYANgQj
BBoASQU6BQYAfwVkBRoAoQU6BRoArQU6BQYA6QVkBRoA9wU6BQYAIQYQBgYAUgY9Bh4AuQasBh4A
EQesBgYA4RHCEQYA/xFdAQYAaRNXEwYAgBNXEwYAnRNXEwYAvBNXEwYA1RNXEwYA7hNXEwYACRRX
EwYAJBRXEwYAPRRXEwYAdhRWFAYAlhRWFAYAtBRdARIA3RTKFBIA6RQHAgYAFBVdARIAKxUTAgYA
ZxVdAQYAeRVdAQYAhhVdARIAkBUHAhIApBUHAgYA4BVdARIA8hUHAhIAAxYHAhIAEhbKFBIAHxYH
AhIATRbKFAYAlhZdARIAqhbKFBIAzBYTAhIA2xbKFBIA7BYHAgYA/BYjBBIAKxfKFBIAWBfKFBIA
rxfKFAYABxhdARIAVBgTAgYAkRhdARoA1Bg6BRoA5xg6BRoADhk6BR4ALhmsBhoAOxk6BRoAYxk6
BR4AeBmsBhoAphmOGRoArBmOGRoA2Bk6BQYA7RlkBQYAWBpFGgYAdRpdAQYAehpdAQYAnhpXEw4A
yhq0Gg4A4xq0GiIABRv4GgoAFBuPASYAbRtNGyYAhRtNGwYAjhtdARoA0xuOGVcA8RsAABoAvReO
GRoA/BuOGQYADhxWFAAAAAABAAAAAAABAAEAAQEQADkAAAAFAAEAAQADAQAAQwAAAAkAAQBQAAEB
EABaAAAABQAEAFAAAQAQAHIAAAAFAAUAWwABARAAfAAAAAUABwBgAAAAEACKAJQABQAJAIIAAQAQ
AMoA1QANAAsAhgADAQAAAAEAAAkADACLAAABEAAOAZQAEQAPAIsAAQAQABcBAAAFABAAjgABABAA
HgEAAAUAIgCzAAEAEAAlAQAABQAlALoAAQAQADcBAAAFACsAxwABABAAQAEAAAUANQDcAAEAEABI
AQAABQBBAPUABgYJBFEDVoARBFQDVoAaBFQDEQBABGIDAQDGBFEDAQDMBFEDNgAQBakDNgApBakD
EQAxBiAFEQBeBiQFEQCnBqkDBgYJBFEDVoDdBkoFVoDlBkoFEQDtBk4FAQBMB3AFAQBwB3AFAQAm
CasFAQA7CakDAQBZCakDAQBwCakDAQCJCVEDAQClCVEDAQDGCa8FAQDiCVEDAQD8CVEDAQAXCqkD
AQArClEDAQBBClEDAQBXClEDAQB2CrIFAQCUCrcFAQC3CrsFAQCcC6kDAQDDC1EDAQDbC6kDAQC/
DKkDAQDhDKkDAQAEDakDAQAlDVEDAQA4DVEDAQBLDe4FAQBlDqkDAQB/Dq8FAQCcDqkDAQC0Dq8F
AQDRDlEDAQDkDlEDAQD3DlEDAQASD6kDAQAlDVEDAQA4DVEDAQCTD6kDAQAmCasFAQA7CakDAQDu
D1EDAQAGEKkDAQAcEFEDAQA0EAYGAQD8CVEDAQAXCqkDAQBOEHAFAQC3CrsFAQBoEFEDAQAmCasF
AQDlEKkDAQClCVEDAQD+EHAFAQAaEXAFUCAAAAAAgRgBAhMAAQBYIAAAAACRAEECFwABAMAgAAAA
AJEAWgIgAAMAWCEAAAAAkQBaAikABQDoIQAAAACRAJkCMgAHAHgiAAAAAJYAqAJEAA4AhCIAAAAA
lgCoAkwAEQDcIgAAAACWAKgCVwAVAD8jAAAAAJYAqAJfABgATCMAAAAAlgCoAmgAGwCYIwAAAACW
AKgCdAAfAPMjAAAAAJYAqAJ9ACIAACQAAAAAlgCoAoYAJQBkJAAAAACWAKgCkgApAN8kAAAAAJYA
wAKbACwA7CQAAAAAlgDAAqQALwBEJQAAAACWAMACsAAzAKclAAAAAJYAwAK5ADYAtCUAAAAAlgDA
AsMAOQAwJgAAAACWAMAC0AA9AIsmAAAAAJYAwALaAEAAmCYAAAAAlgDAAuQAQwAsJwAAAACWAMAC
8QBHAKgnAAAAAJEA3QL7AEoAeCgAAAAAlgDdAgwBUACEKAAAAACWAN0CFQFTAOQoAAAAAJYA3QIh
AVcARykAAAAAlgDdAioBWgBSKQAAAACWAN0CNAFdAGApAAAAAJYA3QJBAWEAuykAAAAAlgDdAksB
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
AACGCIoPawW+AYdKAAAAAIYInA+cA78Bj0oAAAAAhginD6ADvwGYSgAAAACGCLoHZwXAAaBKAAAA
AIYIxgdrBcABqUoAAAAAhgiyD/kFwQGxSgAAAACGCL8P/wXBAbpKAAAAAIYIUAicA8IBwkoAAAAA
hgheCKADwgHLSgAAAACGCGwIZwXDAdNKAAAAAIYIcwhrBcMB3EoAAAAAhghWB3QFxAHkSgAAAACG
CGMHeQXEAe1KAAAAAIYIEAmgBcUB9UoAAAAAhggbCaUFxQH+SgAAAACGCMwPnAPGAQZLAAAAAIYI
3Q+gA8YBD0sAAAAAhhgBAhMAxwEXSwAAAACGCBoHXAXHAR9LAAAAAIYIIgdhBccBKEsAAAAAhgiv
EGcFyAEwSwAAAACGCLsQawXIATlLAAAAAIYI8AecA8kBQUsAAAAAhggECKADyQFKSwAAAACGCMcQ
dAXKAVJLAAAAAIYI1hB5BcoBW0sAAAAAhgiAB3QFywFjSwAAAACGCJMHeQXLAWxLAAAAAIYYAQIT
AMwBAAABAE0RAAACAFURAAABAFURAAACAGcRAAABAFURAAACAG8RAAABAE0RAAACAH8RAAADAIoR
AAAEAJYRAAAFAKIRAAAGAFURAgAHAK4RAAABAO4RAAACAJYRAAADAKIRAAABAO4RAAACAJYRAAAD
AKIRAAAEAFURAAABAO4RAAACABMSAAADAG8RAAABAH8RAAACAJYRAAADAKIRAAABAH8RAAACAJYR
AAADAKIRAAAEAFURAAABAH8RAAACABMSAAADAG8RAAABAIoRAAACAJYRAAADAKIRAAABAIoRAAAC
AJYRAAADAKIRAAAEAFURAAABAIoRAAACABMSAAADAG8RAAABAO4RAAACAJYRAAADAKIRAAABAO4R
AAACAJYRAAADAKIRAAAEAFURAAABAO4RAAACABMSAAADAG8RAAABAH8RAAACAJYRAAADAKIRAAAB
AH8RAAACAJYRAAADAKIRAAAEAFURAAABAH8RAAACABMSAAADAG8RAAABAIoRAAACAJYRAAADAKIR
AAABAIoRAAACAJYRAAADAKIRAAAEAFURAAABAIoRAAACABMSAAADAG8RAAABAH8RAAACAIoRAAAD
AJYRAAAEAKIRAAAFAFURAAAGABoSAAABAO4RAAACAJYRAAADAKIRAAABAO4RAAACAJYRAAADAKIR
AAAEAFURAAABAO4RAAACABMSAAADAG8RAAABAH8RAAACAJYRAAADAKIRAAABAH8RAAACAJYRAAAD
AKIRAAAEAFURAAABAH8RAAACABMSAAADAG8RAAABAIoRAAACAJYRAAADAKIRAAABAIoRAAACAJYR
AAADAKIRAAAEAFURAAABAIoRAAACABMSAAADAG8RAAABAO4RAAACAJYRAAADAKIRAAABAO4RAAAC
AJYRAAADAKIRAAAEAFURAAABAO4RAAACABMSAAADAG8RAAABAH8RAAACAJYRAAADAKIRAAABAH8R
AAACAJYRAAADAKIRAAAEAFURAAABAH8RAAACABMSAAADAG8RAAABAIoRAAACAJYRAAADAKIRAAAB
AIoRAAACAJYRAAADAKIRAAAEAFURAAABAIoRAAACABMSAAADAG8RAAABAH8RAAACAJYRAAADAKIR
AAABAH8RAAACAJYRAAADAKIRAAAEAFURAAABAH8RAAACABMSAAADAG8RAAABAIoRAAACAJYRAAAD
AKIRAAABAIoRAAACAJYRAAADAKIRAAAEAFURAAABAIoRAAACABMSAAADAG8RAAABAO4RAAACAJYR
AAADAKIRAAAEAC4SAAAFADYSAAABAO4RAAACAJYRAAADAKIRAAAEAC4SAAAFADYSAAAGAFURAAAB
AO4RAAACABMSAAADAC4SAAAEADYSAAAFAG8RAAABAH8RAAACAJYRAAADAKIRAAAEAC4SAAAFADYS
AAABAH8RAAACAJYRAAADAKIRAAAEAC4SAAAFADYSAAAGAFURAAABAH8RAAACABMSAAADAC4SAAAE
ADYSAAAFAG8RAAABAIoRAAACAJYRAAADAKIRAAAEAC4SAAAFADYSAAABAIoRAAACAJYRAAADAKIR
AAAEAC4SAAAFADYSAAAGAFURAAABAIoRAAACABMSAAADAC4SAAAEADYSAAAFAG8RAAABAH8RAAAC
AIoRAAADAJYRAAAEAKIRAAAFAC4SAAAGADYSAAAHAFURAAABAEESAAACAE8SAAADAF0SAAAEAC4S
AAAFAGsSAAABAH8RAAACABMSAAADAHUSAAABAO4RAAACABMSAAADAGcRAAABAH8RAAACABMSAAAD
AGcRAAABAIoRAAACABMSAAADAGcRAAABAO4RAAACABMSAAADAGcRAAABAH8RAAACABMSAAADAGcR
AAABAIoRAAACABMSAAADAGcRAAABAO4RAAACABMSAAADAGcRAAABAH8RAAACABMSAAADAGcRAAAB
AIoRAAACABMSAAADAGcRAAABAO4RAAACABMSAAADAGcRAAABAH8RAAACABMSAAADAGcRAAABAIoR
AAACABMSAAADAGcRAAABAH8RAAACABMSAAADAGcRAAABAIoRAAACABMSAAADAGcRAAABAIMSAAAC
AIgSAAADAJESAAABAJsSAAACAKASAAABAKkSAAACAKASAAABAKkSAAABAKkSAAABAH8RAAACABMS
AAADAK8SAAABAMsSAAABAO4RAAACAKIRAAADAFURAAABAO4RAAACAKIRAAABAO4RAAACABMSAAAB
AO4RAAACABMSAAADAK8SAAABAH8RAAACABMSAAABAH8RAAACABMSAAADAK8SAAABAH8RAAACABMS
AAADAK8SAAABAKkSAAABAKkSAAABAN4SAAACAO0SAAABAO4RAAACAPQSAAADAN4SAAAEAO0SAAAB
AN4SAAACAAETAAABAO4RAAACAPQSAAADAN4SAAAEAAETAAABAN4SAAACAO0SAAABAO4RAAACAPQS
AAADAN4SAAAEAO0SAAABAN4SAAACAAkTAAADAA8TAAABAO4RAAACAPQSAAADAN4SAAAEAAkTAAAF
AA8TAAABAN4SAAACAM8KAAABAO4RAAACAPQSAAADAN4SAAAEAM8KAAABAN4SAAABAN4SAAACAAkT
AAABAO4RAAACAPQSAAADAN4SAAAEAAkTAAABAN4SAAACAM8KAAABAO4RAAACAPQSAAADAN4SAAAE
AM8KAAABAN4SAAACAAkTAAABAO4RAAACAPQSAAADAN4SAAAEAAkTAAABAN4SAAACAAkTAAABAN4S
AAACAAkTAAABAN4SAAACAAkTAAABAO4RAAACAPQSAAADAN4SAAAEAAkTAAABAN4SAAACABYTAAAB
AN4SAAACABYTAAADAAkTAAABAN4SAAACABYTAAADABwTAAABAN4SAAACABYTAAADAAkTAAAEABwT
AAAFACMTAAABAN4SAAACAAkTAAADACoTAAABAN4SAAACAAkTAAADACoTAAAEABwTAAABAN4SAAAC
AAkTAAADACoTAAAEACMTAAABAN4SAAACAAkTAAADACoTAAAEABwTAAAFACMTAAABAO4RAAACAPQS
AAADAN4SAAAEAAkTAAAFACoTAAAGABwTAAAHACMTAAABAN4SAAACADQTAAABAO4RAAACAPQSAAAD
AN4SAAAEADQTAAABAKkSAAABAD0TAAACAEcTAAABAD0TAAACAE8TAAABAKkSAAABAKkSAAABAKkS
AAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAAB
AKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkS
AAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAAB
AKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkS
AAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAABAKkSAAAB
AKkSAAABAKkSAAABAKkSAAABAKkS2QABAhMA4QABAhMA6QABAmsF8QABAmsF+QABAmsFAQEBAmsF
CQEBAmsFEQEBAmsFGQEBAmsFIQEBAmsFKQEBAmsFMQEBAqADOQEBAhMACQABAhMAQQEBAmsFSQH8
FBEGSQEKFRcGWQEbFRsGSQEhFSAGKQBCFSUGYQFRFSsGSQFVFWcFaQFuFZwDaQF/FTsGeQEBAmsF
OQCaFUIGgQG5FUgGaQHFFU4GiQHPFVMGOQDXFVgGkQEBAmsFoQEKFRcGqQEvFm8GqQE5FhMAKQA+
FnUGuQFXFmsFSQBnFnsGkQEBAoAGKQB2FoYGuQGGFowGQQABAmsFwQGiFhMAKQABAhMAuQGoApwD
yQHAFhMAqQHGFhMA0QEBAqwGWQABAhMA2QHnFrIGKQDdAsUGKQDdAsoGyQEIF9IG6QEWFxcG6QEi
F38FuQHrAhcGKQAOA/8G2QFGFxsH8QFRFSEHcQFpF2cFaQFyFykH0QEBAhMA0QF5F6wG0QGLF6wG
0QGdF6wGAQK9FzsHWQDEFxMAKQABAkgHSQHSF2sFOQDjF1gHaQHxF10HaQH/F2IHaQEMGGgHeQAU
GHMHeQAaGHkHDAABAogHeQAmGHkHFAABAogHFAA1GH8FFABCGLAHFAAKFbAHEQJmGL0HyQF3GKAD
yQGAGJwDYQGKGMMHGQKcGBcGaQFyF+EHgQCiGOgHgQDXFfIHqQGrGGcFaQFyFwoIgQABAhMAgQDH
GCAIiQABAhMAIQLgGC8IIQL1GDYIIQIBGT0IKQIgGUYIQQJLGVgIQQJSGXYIQQJeGVgIQQK9F7YI
0QBvGcIIUQKCGcoIWQK6GdIIQQK9GdwIQQLEGfsIQQLOGQAJQQLOGSIJQQLjBT4JLAABAhMAQQLm
GWAJNAAIF3UJPAAWF7AHLABRFYgHQQL7Ga8JNAAFGroJNAASGsYJNAAcGtIJNAAkGtIJQQItGgcK
QQI5Gg0KeQIBAhMAgQKMGicKgQKnGjAKuQABAjYKmQIBAkMKqQIBAmsFGQAmG40KsQJ3G5MKuQLX
FZkKwQIKFRcGyQKWG6AKeQChG5wDeQCqG5wDeQC0G5wDeQABAqYKeQC8G60KyQDgGLIKsQLEG6AD
WQLmG8gKWQLqG8gKWQLtG9IKRAAIF+cKTAAWF7AHUQKCGfkK4QIKHAALTAAiF38FGQABAhMA8QIB
AhMAIQABAhMAeQApHHQFCAAIAFgDCAAMAF0DCAA0AFgDCAA4AF0DLgA7ADkLLgBLAGkLLgAjAGkL
LgArAGkLLgBDAG8LLgAbADkLLgBjAIYLLgBrAI8LLgAzAGkLaQDzA0oKiQDzA0oK4wDTA10DAwH7
A1MK4QGrBF0DQQKrBF0DYQKrBF0DgQKrBF0DhAITAF0DoQKrBF0DwQKrBF0D4QKrBF0D5AITAF0D
AQOrBF0DIQOrBF0DQQOrBF0DYQOrBF0DgQOrBF0DoQOrBF0DwQOrBF0DxAMTAF0D4QOrBF0DAQSr
BF0DIQSrBF0DJAQTAF0DYQSrBF0DgQSrBF0DoQSrBF0DwQSrBF0D4QSrBF0DAQWrBF0DBAUTAF0D
IQWrBF0DQQWrBF0DYQWrBF0DZAUTAF0DgQWrBF0DoQWrBF0DwQWrBF0D4QWrBF0DAQarBF0DIQar
BF0DQQarBF0DRAYTAF0DYQarBF0DgQarBF0DpAYTAF0DwQarBF0D4QarBF0DAQerBF0DIQerBF0D
QQerBF0DYQerBF0DgQerBF0DhAcTAF0DoQerBF0DwQerBF0D4QerBF0D5AcTAF0DAQirBF0DIQir
BF0DQQirBF0DYQirBF0DgQirBF0DoQirBF0DxAgTAF0DJAkTAF0DxAoTAF0DJAsTAF0DBAwTAF0D
ZAwTAF0DRA0TAF0DpA0TAF0DhA4TAF0D5A4TAF0DxA8TAF0DJBATAF0DBBETAF0DZBETAF0DwBGr
BF0D4BGrBF0DABKrBF0DIBKrBF0DRBITAF0DpBITAF0DwBKrBF0D4BKrBF0DABOrBF0DIBOrBF0D
QBOrBF0DYBOrBF0DgBOrBF0DhBMTAF0DoBOrBF0DwBOrBF0D4BOrBF0D5BMTAF0DABSrBF0DIBSr
BF0DQBSrBF0DYBSrBF0DgBSrBF0DoBSrBF0DwBSrBF0D4BSrBF0DABWrBF0DIBWrBF0DQBWrBF0D
RBUTAF0DYBWrBF0DgBWrBF0DoBWrBF0DwBWrBF0D4BWrBF0D5BUTAF0DABarBF0DIBarBF0DYBar
BF0DgBarBF0DoBarBF0DwBarBF0DQBerBF0DRBcTAF0DYBerBF0DgBerBF0DoBerBF0DwBerBF0D
4BerBF0D5BcTAF0DABirBF0DIBirBF0DQBirBF0DYBirBF0DgBirBF0DoBirBF0D4BirBF0DABmr
BF0DIBmrBF0DQBmrBF0DRBkTAF0DYBmrBF0DgBmrBF0DoBmrBF0DwBmrBF0D4BmrBF0D5BkTAF0D
ABqrBF0DIBqrBF0DQBqrBF0DYBqrBF0DgBqrBF0DoBqrBF0DwBqrBF0DxBoTAF0D4BqrBF0DABur
BF0DIBurBF0DQBurBF0DgBurBF0DoBurBF0DwBurBF0DxBsTAF0D4BurBF0DAByrBF0DIByrBF0D
QByrBF0DYByrBF0DgByrBF0DoByrBF0DAB2rBF0DIB2rBF0DQB2rBF0DYB2rBF0DgB2rBF0DoB2r
BF0DwB2rBF0D4B2rBF0DAB6rBF0DIB6rBF0DQB6rBF0DYB6rBF0DoB6rBF0DwB6rBF0D4B6rBF0D
AB+rBF0DIB+rBF0DQB+rBF0DYB+rBF0DgB+rBF0DoB+rBF0DwB+rBF0DBCMTAF0DZC4TAF0DxC8T
AF0DZDATAF0DRDETAF0DhDETAF0DBDITAF0DMgZdBmcGkgaYBp4GpQa4BtgG6wbyBvgGBAcOBxYH
LwdCB08HbgeOB6MHtQfLB9kH7gf7BwIIEghgCIYIoAjjCAgJKAlECYcJqgndCRMKPgq5Cg0LLQsF
AAEABwADAAoABQALAAYADAAYAA0AGwAOACEADwArABAANwAAAAIFpQMAAAcFpQMAACEGOAUAAJoG
PQUAAAkHVwUAAM8KvwUAANMKxAUAAOAKyAUAAOkKyAUAAPgKxAUAAP4KxAUAAAYLpQMAABELpQMA
ACELzQUAACwLpQMAADULpQMAAD8LxAUAAEILpQMAAEcLpQMAAEwLpQMAAFoL0QUAACUB1wUAAGcL
3AUAAPQLpQMAAPsLxAUAAAMMxAUAAGYNxAUAAHcNxAUAAIkNxAUAAJkNpQMAAJsNpQMAAJ0N8wUA
ACwPxAUAADUPzQUAAEEPxAUAAEgPzQUAAFQPpQMAAFYPpQMAAFgPpQMAAGIPxAUAAJkNpQMAAJsN
pQMAAM8KvwUAANMKxAUAAIYQpQMAAI0QxAUAAJIQpQMAAP4KxAUAAJkQCwYAADULpQMAAD8LxAUA
AOAKyAUAAGcL3AUAAKIQpQMAAM8KvwUAADoRxAUAABELpQMAAEIRyAUAAOkKyAUCAFsAAwABAFwA
AwACAF0ABQABAF4ABQACAIMABwACAIQACQABAIUACQACAIsACwACAI4ADQABAI8ADQACAJAADwAB
AJEADwACAJIAEQABAJMAEQABAJUAEwACAJQAEwACAJYAFQABAJcAFQABAJkAFwACAJgAFwACAJoA
GQABAJsAGQACAJwAGwABAJ0AGwACAJ4AHQABAJ8AHQABAKEAHwACAKAAHwABAKMAIQACAKIAIQAC
AKQAIwABAKUAIwABAKcAJQACAKYAJQACAKgAJwABAKkAJwACAKoAKQABAKsAKQACAKwAKwABAK0A
KwABAK8ALQACAK4ALQACALAALwABALEALwACALMAMQABALQAMQACALUAMwABALYAMwACALcANQAB
ALgANQACALoANwABALsANwACALwAOQABAL0AOQACAL4AOwABAL8AOwABAMEAPQACAMAAPQABAMMA
PwACAMIAPwACAMQAQQABAMUAQQABAMgAQwACAMcAQwACAMkARQABAMoARQACAMsARwABAMwARwAC
AM0ASQABAM4ASQABANAASwACAM8ASwACANEATQABANIATQACANMATwABANQATwACANUAUQABANYA
UQACANcAUwABANgAUwACANkAVQABANoAVQACANwAVwABAN0AVwACAN4AWQABAN8AWQACAOAAWwAB
AOEAWwABAOMAXQACAOIAXQACAOQAXwABAOUAXwABAOcAYQACAOYAYQACAOgAYwABAOkAYwACAOoA
ZQABAOsAZQACAOwAZwABAO0AZwABAO8AaQACAO4AaQACAPAAawABAPEAawACAPIAbQABAPMAbQAC
APUAbwABAPYAbwACAPcAcQABAPgAcQACAPkAcwABAPoAcwACAPsAdQABAPwAdQACAP0AdwABAP4A
dwCBB50H9wcsCFkJbQl/CeAK8QoEgAAAAQAAACsREE4AAAAAAADVAAAAAgAAAAAAAAAAAAAAAQBU
AQAAAAAKAAAAAAAAAAAAAAAKAHABAAAAAAIAAAAAAAAAAAAAAAEAXQEAAAAAAgAAAAAAAAAAAAAA
AQAHAgAAAAACAAAAAAAAAAAAAAABAPkCAAAAAAEAAwABAP0QAAAAAKwDOgUAAAAAAQADAAEA/RAA
AAAArAOsBgAAAAADAAUAAAAAAAAAAAABAPgaAAAAAAoAAAAAAAAAAAAAAAoALhsAAAAAAAAAAAEA
AAA1HAAAAwACAAkACAAAAAAAwQBiBQAAAADDAGIFAAAAAMUAYgUAAAAAxwBiBQAAAADJAGIFAAAA
AMsAYgUAAAAAzQBiBQAAAADPAGIFAAAAANsAYgUAAAAA3QBiBQAAAADfAGIFAAAAAOEAYgUAAAAA
5wBiBQAAAADpAGIFAAAAAOsAYgUAAAAA7QBiBQAAAADvAGIFAAAAAPEAYgUAAAAA8wBiBQAAAAD1
AGIFAAAAAPcAYgUAAAAA+QBiBQAAAAD7AGIFwgAnCMMAUgjFACcIxgAnCMcAJwjKACcIyQAnCM4A
JwjcACcI1wAnCOAAJwjZACcI6AAnCN8AJwjwACcI+gAnCOcAJwjmANsKzAAIC8QA2wrmACgLxAAo
CwAAAAAAPE1vZHVsZT4AU1RfMjZmMDBmNWY1Y2I4NGRlNmE0YWQ4OGEzOGMzN2Y3MmMuY3Nwcm9q
LmRsbABTcWxIZWxwZXIAU3FsQ29ubmVjdGlvbk93bmVyc2hpcABTcWxIZWxwZXJQYXJhbWV0ZXJD
YWNoZQBQYWdlckluZm8ATW9uZ29EQkhlbHBlcgBSZXNvdXJjZXMAU1RfMjZmMDBmNWY1Y2I4NGRl
NmE0YWQ4OGEzOGMzN2Y3MmMuY3Nwcm9qLlByb3BlcnRpZXMAU2NyaXB0TWFpbgBTVF8yNmYwMGY1
ZjVjYjg0ZGU2YTRhZDg4YTM4YzM3ZjcyYy5jc3Byb2oAU2NyaXB0UmVzdWx0cwBTZXR0aW5ncwBN
X1Bvc3QATV9Vc2VyAENhcmRGb3JtYXRpb25JbmZvAENhcmRJbmZvAENvbW1lbnQAQ3VzdG9tZXJU
YWcAbXNjb3JsaWIAU3lzdGVtAE9iamVjdABFbnVtAE1pY3Jvc29mdC5TcWxTZXJ2ZXIuU2NyaXB0
VGFzawBNaWNyb3NvZnQuU3FsU2VydmVyLkR0cy5UYXNrcy5TY3JpcHRUYXNrAFZTVEFSVFNjcmlw
dE9iamVjdE1vZGVsQmFzZQBTeXN0ZW0uQ29uZmlndXJhdGlvbgBBcHBsaWNhdGlvblNldHRpbmdz
QmFzZQAuY3RvcgBTeXN0ZW0uRGF0YQBTeXN0ZW0uRGF0YS5TcWxDbGllbnQAU3FsQ29tbWFuZABT
cWxQYXJhbWV0ZXIAQXR0YWNoUGFyYW1ldGVycwBEYXRhUm93AEFzc2lnblBhcmFtZXRlclZhbHVl
cwBTcWxDb25uZWN0aW9uAFNxbFRyYW5zYWN0aW9uAENvbW1hbmRUeXBlAFByZXBhcmVDb21tYW5k
AEV4ZWN1dGVOb25RdWVyeQBEYXRhU2V0AEV4ZWN1dGVEYXRhc2V0AFNxbERhdGFSZWFkZXIARXhl
Y3V0ZVJlYWRlcgBFeGVjdXRlU2NhbGFyAFN5c3RlbS5YbWwAWG1sUmVhZGVyAEV4ZWN1dGVYbWxS
ZWFkZXIARmlsbERhdGFzZXQAVXBkYXRlRGF0YXNldABDcmVhdGVDb21tYW5kAEV4ZWN1dGVOb25R
dWVyeVR5cGVkUGFyYW1zAEV4ZWN1dGVEYXRhc2V0VHlwZWRQYXJhbXMARXhlY3V0ZVJlYWRlclR5
cGVkUGFyYW1zAEV4ZWN1dGVTY2FsYXJUeXBlZFBhcmFtcwBFeGVjdXRlWG1sUmVhZGVyVHlwZWRQ
YXJhbXMAU2VjTGlrZQBOdWxsYWJsZWAxAERhdGVUaW1lAFNlY0RhdGUAU2VjSW50AFNlY0ludE1h
eABTZWNJbnRNaW4AdmFsdWVfXwBJbnRlcm5hbABFeHRlcm5hbABTeXN0ZW0uQ29sbGVjdGlvbnMA
SGFzaHRhYmxlAHBhcmFtQ2FjaGUARGlzY292ZXJTcFBhcmFtZXRlclNldABDbG9uZVBhcmFtZXRl
cnMAQ2FjaGVQYXJhbWV0ZXJTZXQAR2V0Q2FjaGVkUGFyYW1ldGVyU2V0AEdldFNwUGFyYW1ldGVy
U2V0AEdldFNwUGFyYW1ldGVyU2V0SW50ZXJuYWwAX1BhZ2UAX1BhZ2VTaXplAGdldF9QYWdlAHNl
dF9QYWdlAGdldF9QYWdlU2l6ZQBzZXRfUGFnZVNpemUAUGFnZQBQYWdlU2l6ZQBjb25uZWN0aW9u
U3RyaW5nX0RlZmF1bHQAZGF0YWJhc2VfRGVmYXVsdABNb25nb0RCLkRyaXZlcgBTYWZlTW9kZVJl
c3VsdABJbnNlcnRPbmUAVABTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYwBJRW51bWVyYWJsZWAx
AEluc2VydEFsbABVcGRhdGVPbmUASU1vbmdvUXVlcnkASU1vbmdvVXBkYXRlAFVwZGF0ZUFsbABE
ZWxldGUARGVsZXRlQWxsAEdldE9uZQBFeGlzdHMAQ291bnQATGlzdGAxAEdldEFsbABJTW9uZ29T
b3J0QnkAQ3JlYXRlSW5kZXgAU3lzdGVtLlJlc291cmNlcwBSZXNvdXJjZU1hbmFnZXIAcmVzb3Vy
Y2VNYW4AU3lzdGVtLkdsb2JhbGl6YXRpb24AQ3VsdHVyZUluZm8AcmVzb3VyY2VDdWx0dXJlAGdl
dF9SZXNvdXJjZU1hbmFnZXIAZ2V0X0N1bHR1cmUAc2V0X0N1bHR1cmUAQ3VsdHVyZQBNYWluAGNv
bm4ATW9uZ29EQi5Cc29uAEJzb25EYXRlVGltZQBUb0Zvcm1hdGlvbgBUb0NvbW1lbnRzAFN1Y2Nl
c3MARmFpbHVyZQBkZWZhdWx0SW5zdGFuY2UAZ2V0X0RlZmF1bHQARGVmYXVsdABPYmplY3RJZABn
ZXRfX2lkAHNldF9faWQAZ2V0X19pZEZvclN0cmluZwBzZXRfX2lkRm9yU3RyaW5nAF9Qb3N0VGlt
ZQBnZXRfUG9zdFRpbWUAc2V0X1Bvc3RUaW1lAF9MYXN0TW9kaWZ5VGltZQBnZXRfTGFzdE1vZGlm
eVRpbWUAc2V0X0xhc3RNb2RpZnlUaW1lAGdldF9UaXRsZQBzZXRfVGl0bGUAZ2V0X0NvbnRlbnQA
c2V0X0NvbnRlbnQAZ2V0X1JlcGx5Q291bnQAc2V0X1JlcGx5Q291bnQAZ2V0X1BvcHVsYXJpdHlD
b3VudABzZXRfUG9wdWxhcml0eUNvdW50AGdldF9BdWRpdFN0YXRlAHNldF9BdWRpdFN0YXRlAGdl
dF9Qb3N0VHlwZQBzZXRfUG9zdFR5cGUAZ2V0X1Bvc3RTdGF0ZQBzZXRfUG9zdFN0YXRlAGdldF9J
UABzZXRfSVAAZ2V0X01hcmsAc2V0X01hcmsAZ2V0X0Rvd24Ac2V0X0Rvd24AZ2V0X0FsbFRha2VQ
YXJ0SW4Ac2V0X0FsbFRha2VQYXJ0SW4AZ2V0X0N1c3RvbWVyVGFncwBzZXRfQ3VzdG9tZXJUYWdz
AGdldF9DYXJkRm9ybWF0aW9uSW5mbwBzZXRfQ2FyZEZvcm1hdGlvbkluZm8AZ2V0X21fVXNlcgBz
ZXRfbV9Vc2VyADxfaWQ+a19fQmFja2luZ0ZpZWxkADxfaWRGb3JTdHJpbmc+a19fQmFja2luZ0Zp
ZWxkADxUaXRsZT5rX19CYWNraW5nRmllbGQAPENvbnRlbnQ+a19fQmFja2luZ0ZpZWxkADxSZXBs
eUNvdW50PmtfX0JhY2tpbmdGaWVsZAA8UG9wdWxhcml0eUNvdW50PmtfX0JhY2tpbmdGaWVsZAA8
QXVkaXRTdGF0ZT5rX19CYWNraW5nRmllbGQAPFBvc3RUeXBlPmtfX0JhY2tpbmdGaWVsZAA8UG9z
dFN0YXRlPmtfX0JhY2tpbmdGaWVsZAA8SVA+a19fQmFja2luZ0ZpZWxkADxNYXJrPmtfX0JhY2tp
bmdGaWVsZAA8RG93bj5rX19CYWNraW5nRmllbGQAPEFsbFRha2VQYXJ0SW4+a19fQmFja2luZ0Zp
ZWxkADxDdXN0b21lclRhZ3M+a19fQmFja2luZ0ZpZWxkADxDYXJkRm9ybWF0aW9uSW5mbz5rX19C
YWNraW5nRmllbGQAPG1fVXNlcj5rX19CYWNraW5nRmllbGQAX2lkAF9pZEZvclN0cmluZwBQb3N0
VGltZQBMYXN0TW9kaWZ5VGltZQBUaXRsZQBDb250ZW50AFJlcGx5Q291bnQAUG9wdWxhcml0eUNv
dW50AEF1ZGl0U3RhdGUAUG9zdFR5cGUAUG9zdFN0YXRlAElQAE1hcmsARG93bgBBbGxUYWtlUGFy
dEluAEN1c3RvbWVyVGFncwBtX1VzZXIAZ2V0X1VzZXJJRABzZXRfVXNlcklEAGdldF9OaWNOYW1l
AHNldF9OaWNOYW1lAF9BdmF0YXJVUkwAZ2V0X0F2YXRhclVSTABzZXRfQXZhdGFyVVJMADxVc2Vy
SUQ+a19fQmFja2luZ0ZpZWxkADxOaWNOYW1lPmtfX0JhY2tpbmdGaWVsZABVc2VySUQATmljTmFt
ZQBBdmF0YXJVUkwAZ2V0X0NhcmRGb3JtYXRpb25VcmwAc2V0X0NhcmRGb3JtYXRpb25VcmwAZ2V0
X0NhcmRGb3JtYXRpb25OYW1lAHNldF9DYXJkRm9ybWF0aW9uTmFtZQBnZXRfQ2FyZEZvcm1hdGlv
bklEAHNldF9DYXJkRm9ybWF0aW9uSUQAZ2V0X1cAc2V0X1cAZ2V0X0gAc2V0X0gAZ2V0X0NhcmRJ
bmZvcwBzZXRfQ2FyZEluZm9zADxDYXJkRm9ybWF0aW9uVXJsPmtfX0JhY2tpbmdGaWVsZAA8Q2Fy
ZEZvcm1hdGlvbk5hbWU+a19fQmFja2luZ0ZpZWxkADxDYXJkRm9ybWF0aW9uSUQ+a19fQmFja2lu
Z0ZpZWxkADxXPmtfX0JhY2tpbmdGaWVsZAA8SD5rX19CYWNraW5nRmllbGQAPENhcmRJbmZvcz5r
X19CYWNraW5nRmllbGQAQ2FyZEZvcm1hdGlvblVybABDYXJkRm9ybWF0aW9uTmFtZQBDYXJkRm9y
bWF0aW9uSUQAVwBIAENhcmRJbmZvcwBnZXRfQ2FyZE5hbWUAc2V0X0NhcmROYW1lAGdldF9Jc0hh
bmRzdGFuZABzZXRfSXNIYW5kc3RhbmQAZ2V0X0ltZ1VybABzZXRfSW1nVXJsAGdldF9Jc1BvaW50
Q2FyZABzZXRfSXNQb2ludENhcmQAZ2V0X1gAc2V0X1gAZ2V0X1kAc2V0X1kAZ2V0X1NvcnRJbmRl
eABzZXRfU29ydEluZGV4AGdldF9EZXNjcmliZQBzZXRfRGVzY3JpYmUAPENhcmROYW1lPmtfX0Jh
Y2tpbmdGaWVsZAA8SXNIYW5kc3RhbmQ+a19fQmFja2luZ0ZpZWxkADxJbWdVcmw+a19fQmFja2lu
Z0ZpZWxkADxJc1BvaW50Q2FyZD5rX19CYWNraW5nRmllbGQAPFg+a19fQmFja2luZ0ZpZWxkADxZ
PmtfX0JhY2tpbmdGaWVsZAA8U29ydEluZGV4PmtfX0JhY2tpbmdGaWVsZAA8RGVzY3JpYmU+a19f
QmFja2luZ0ZpZWxkAENhcmROYW1lAElzSGFuZHN0YW5kAEltZ1VybABJc1BvaW50Q2FyZABYAFkA
U29ydEluZGV4AERlc2NyaWJlAGdldF9fSW5kZXgAc2V0X19JbmRleABnZXRfRktpZABzZXRfRktp
ZABfQ29udGVudABnZXRfRktUeXBlAHNldF9GS1R5cGUAZ2V0X0NoaWxkcmVuAHNldF9DaGlsZHJl
bgBnZXRfQ29tbWVudExldmVsAHNldF9Db21tZW50TGV2ZWwAPF9JbmRleD5rX19CYWNraW5nRmll
bGQAPEZLaWQ+a19fQmFja2luZ0ZpZWxkADxGS1R5cGU+a19fQmFja2luZ0ZpZWxkADxDaGlsZHJl
bj5rX19CYWNraW5nRmllbGQAPFBvc3RUaW1lPmtfX0JhY2tpbmdGaWVsZAA8Q29tbWVudExldmVs
PmtfX0JhY2tpbmdGaWVsZABfSW5kZXgARktpZABGS1R5cGUAQ2hpbGRyZW4AQ29tbWVudExldmVs
AGdldF9UYWdOYW1lAHNldF9UYWdOYW1lAGdldF9DcmVhdGVUaW1lAHNldF9DcmVhdGVUaW1lADxU
YWdOYW1lPmtfX0JhY2tpbmdGaWVsZAA8Q3JlYXRlVGltZT5rX19CYWNraW5nRmllbGQAPExhc3RN
b2RpZnlUaW1lPmtfX0JhY2tpbmdGaWVsZABUYWdOYW1lAENyZWF0ZVRpbWUAY29tbWFuZABjb21t
YW5kUGFyYW1ldGVycwBkYXRhUm93AHBhcmFtZXRlclZhbHVlcwBjb25uZWN0aW9uAHRyYW5zYWN0
aW9uAGNvbW1hbmRUeXBlAGNvbW1hbmRUZXh0AG11c3RDbG9zZUNvbm5lY3Rpb24AU3lzdGVtLlJ1
bnRpbWUuSW50ZXJvcFNlcnZpY2VzAE91dEF0dHJpYnV0ZQBjb25uZWN0aW9uU3RyaW5nAFBhcmFt
QXJyYXlBdHRyaWJ1dGUAc3BOYW1lAGNvbm5lY3Rpb25Pd25lcnNoaXAAZGF0YVNldAB0YWJsZU5h
bWVzAGluc2VydENvbW1hbmQAZGVsZXRlQ29tbWFuZAB1cGRhdGVDb21tYW5kAHRhYmxlTmFtZQBz
b3VyY2VDb2x1bW5zAGxpa2UAcHJlTWF0Y2gAbGFzdE1hdGNoAGRhdGUAbnVsbGFibGUAdmFsdWUA
aW5jbHVkZVJldHVyblZhbHVlUGFyYW1ldGVyAG9yaWdpbmFsUGFyYW1ldGVycwBjb2xsZWN0aW9u
TmFtZQBlbnRpdHkAZGF0YWJhc2VOYW1lAGVudGl0eXMAcXVlcnkAdXBkYXRlAGNvdW50AHNvcnRC
eQBmaWVsZHMAcGFnZXJJbmZvAGtleU5hbWVzAHN0YXJ0VGltZQBlbmR0aW1lAGVudFRpbWUAU3lz
dGVtLlJlZmxlY3Rpb24AQXNzZW1ibHlUaXRsZUF0dHJpYnV0ZQBBc3NlbWJseURlc2NyaXB0aW9u
QXR0cmlidXRlAEFzc2VtYmx5Q29uZmlndXJhdGlvbkF0dHJpYnV0ZQBBc3NlbWJseUNvbXBhbnlB
dHRyaWJ1dGUAQXNzZW1ibHlQcm9kdWN0QXR0cmlidXRlAEFzc2VtYmx5Q29weXJpZ2h0QXR0cmli
dXRlAEFzc2VtYmx5VHJhZGVtYXJrQXR0cmlidXRlAEFzc2VtYmx5Q3VsdHVyZUF0dHJpYnV0ZQBB
c3NlbWJseVZlcnNpb25BdHRyaWJ1dGUAU3lzdGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcwBD
b21waWxhdGlvblJlbGF4YXRpb25zQXR0cmlidXRlAFJ1bnRpbWVDb21wYXRpYmlsaXR5QXR0cmli
dXRlAEFyZ3VtZW50TnVsbEV4Y2VwdGlvbgBTeXN0ZW0uRGF0YS5Db21tb24ARGJQYXJhbWV0ZXIA
UGFyYW1ldGVyRGlyZWN0aW9uAGdldF9EaXJlY3Rpb24AZ2V0X1ZhbHVlAERCTnVsbABWYWx1ZQBz
ZXRfVmFsdWUAU3FsUGFyYW1ldGVyQ29sbGVjdGlvbgBnZXRfUGFyYW1ldGVycwBBZGQAZ2V0X1Bh
cmFtZXRlck5hbWUAU3RyaW5nAGdldF9MZW5ndGgASW50MzIARm9ybWF0AEV4Y2VwdGlvbgBEYXRh
VGFibGUAZ2V0X1RhYmxlAERhdGFDb2x1bW5Db2xsZWN0aW9uAGdldF9Db2x1bW5zAFN1YnN0cmlu
ZwBJbmRleE9mAGdldF9JdGVtAEFyZ3VtZW50RXhjZXB0aW9uAElEYkRhdGFQYXJhbWV0ZXIASURh
dGFQYXJhbWV0ZXIARGJDb25uZWN0aW9uAENvbm5lY3Rpb25TdGF0ZQBnZXRfU3RhdGUAT3BlbgBz
ZXRfQ29ubmVjdGlvbgBEYkNvbW1hbmQAc2V0X0NvbW1hbmRUZXh0AGdldF9Db25uZWN0aW9uAHNl
dF9UcmFuc2FjdGlvbgBzZXRfQ29tbWFuZFR5cGUASURpc3Bvc2FibGUARGlzcG9zZQBEYlBhcmFt
ZXRlckNvbGxlY3Rpb24AQ2xlYXIAQ2xvc2UAU3FsRGF0YUFkYXB0ZXIARGF0YUFkYXB0ZXIARmls
bABDb21tYW5kQmVoYXZpb3IASUVudW1lcmF0b3IAR2V0RW51bWVyYXRvcgBnZXRfQ3VycmVudABN
b3ZlTmV4dABEYXRhVGFibGVNYXBwaW5nQ29sbGVjdGlvbgBnZXRfVGFibGVNYXBwaW5ncwBEYXRh
VGFibGVNYXBwaW5nAFRvU3RyaW5nAENvbmNhdABzZXRfVXBkYXRlQ29tbWFuZABzZXRfSW5zZXJ0
Q29tbWFuZABzZXRfRGVsZXRlQ29tbWFuZABEYkRhdGFBZGFwdGVyAFVwZGF0ZQBBY2NlcHRDaGFu
Z2VzAHNldF9Tb3VyY2VDb2x1bW4AZ2V0X0l0ZW1BcnJheQBJc051bGxPckVtcHR5AFJlcGxhY2UA
Q2hhcgBUcmltRW5kAFBhcnNlAG9wX0xlc3NUaGFuAG9wX0dyZWF0ZXJUaGFuAGdldF9IYXNWYWx1
ZQBHZXRWYWx1ZU9yRGVmYXVsdABTcWxDb21tYW5kQnVpbGRlcgBEZXJpdmVQYXJhbWV0ZXJzAFJl
bW92ZUF0AGdldF9Db3VudABDb3B5VG8ASUNsb25lYWJsZQBDbG9uZQBzZXRfSXRlbQBnZXRfQ29u
bmVjdGlvblN0cmluZwAuY2N0b3IAU3luY2hyb25pemVkAE1vbmdvU2VydmVyAENyZWF0ZQBNb25n
b0RhdGFiYXNlAEdldERhdGFiYXNlAFJlcXVlc3RTdGFydABNb25nb0NvbGxlY3Rpb25gMQBHZXRD
b2xsZWN0aW9uAEJzb25Eb2N1bWVudABNb25nb0NvbGxlY3Rpb24ASW5zZXJ0AEluc2VydEJhdGNo
AFNhdmUAVXBkYXRlRmxhZ3MAVHJ5UGFyc2UAQnNvblZhbHVlAG9wX0ltcGxpY2l0AE1vbmdvREIu
RHJpdmVyLkJ1aWxkZXJzAFF1ZXJ5AFF1ZXJ5Q29tcGxldGUARVEAUmVtb3ZlAFJlbW92ZUFsbABG
aW5kT25lQXMATW9uZ29DdXJzb3JgMQBGaW5kQXMASUVudW1lcmF0b3JgMQBGaW5kQWxsQXMAU2V0
U29ydE9yZGVyAFNldEZpZWxkcwBTZXRTa2lwAFNldExpbWl0AEluZGV4RXhpc3RzAEVuc3VyZUlu
ZGV4AFN5c3RlbS5EaWFnbm9zdGljcwBEZWJ1Z2dlck5vblVzZXJDb2RlQXR0cmlidXRlAFR5cGUA
UnVudGltZVR5cGVIYW5kbGUAR2V0VHlwZUZyb21IYW5kbGUAQXNzZW1ibHkAZ2V0X0Fzc2VtYmx5
AFN5c3RlbS5Db21wb25lbnRNb2RlbABFZGl0b3JCcm93c2FibGVBdHRyaWJ1dGUARWRpdG9yQnJv
d3NhYmxlU3RhdGUAU3lzdGVtLkFkZEluAEFkZEluQXR0cmlidXRlAFNjcmlwdE9iamVjdE1vZGVs
AGdldF9EdHMATWljcm9zb2Z0LlNxbFNlcnZlci5NYW5hZ2VkRFRTAE1pY3Jvc29mdC5TcWxTZXJ2
ZXIuRHRzLlJ1bnRpbWUAVmFyaWFibGVzAGdldF9WYXJpYWJsZXMAVmFyaWFibGUAQ29udmVydABU
b0RhdGVUaW1lAGdldF9ZZWFyAGdldF9Nb250aABnZXRfRGF5AGdldF9Ob3cAc2V0X1Rhc2tSZXN1
bHQAUXVlcnlDb25kaXRpb25MaXN0AEdURQBMVABBbmQARW51bWVyYXRvcgBVcGRhdGVCdWlsZGVy
AEluYwBDb21waWxlckdlbmVyYXRlZEF0dHJpYnV0ZQBUb0xvY2FsVGltZQBTVF8yNmYwMGY1ZjVj
Yjg0ZGU2YTRhZDg4YTM4YzM3ZjcyYy5jc3Byb2ouUHJvcGVydGllcy5SZXNvdXJjZXMucmVzb3Vy
Y2VzAAAAD2MAbwBtAG0AYQBuAGQAAIDvUABsAGUAYQBzAGUAIABwAHIAbwB2AGkAZABlACAAYQAg
AHYAYQBsAGkAZAAgAHAAYQByAGEAbQBlAHQAZQByACAAbgBhAG0AZQAgAG8AbgAgAHQAaABlACAA
cABhAHIAYQBtAGUAdABlAHIAIAAjAHsAMAB9ACwAIAB0AGgAZQAgAFAAYQByAGEAbQBlAHQAZQBy
AE4AYQBtAGUAIABwAHIAbwBwAGUAcgB0AHkAIABoAGEAcwAgAHQAaABlACAAZgBvAGwAbABvAHcA
aQBuAGcAIAB2AGEAbAB1AGUAOgAgACcAewAxAH0AJwAuAAFrUABhAHIAYQBtAGUAdABlAHIAIABj
AG8AdQBuAHQAIABkAG8AZQBzACAAbgBvAHQAIABtAGEAdABjAGgAIABQAGEAcgBhAG0AZQB0AGUA
cgAgAFYAYQBsAHUAZQAgAGMAbwB1AG4AdAAuAAAXYwBvAG0AbQBhAG4AZABUAGUAeAB0AACAn1QA
aABlACAAdAByAGEAbgBzAGEAYwB0AGkAbwBuACAAdwBhAHMAIAByAG8AbABsAGIAYQBjAGsAZQBk
ACAAbwByACAAYwBvAG0AbQBpAHQAZQBkACwAIABwAGwAZQBhAHMAZQAgAHAAcgBvAHYAaQBkAGUA
IABhAG4AIABvAHAAZQBuACAAdAByAGEAbgBzAGEAYwB0AGkAbwBuAC4AABd0AHIAYQBuAHMAYQBj
AHQAaQBvAG4AACFjAG8AbgBuAGUAYwB0AGkAbwBuAFMAdAByAGkAbgBnAAANcwBwAE4AYQBtAGUA
ABVjAG8AbgBuAGUAYwB0AGkAbwBuAAAPZABhAHQAYQBTAGUAdAAAC1QAYQBiAGwAZQAAgMtUAGgA
ZQAgAHQAYQBiAGwAZQBOAGEAbQBlAHMAIABwAGEAcgBhAG0AZQB0AGUAcgAgAG0AdQBzAHQAIABj
AG8AbgB0AGEAaQBuACAAYQAgAGwAaQBzAHQAIABvAGYAIAB0AGEAYgBsAGUAcwAsACAAYQAgAHYA
YQBsAHUAZQAgAHcAYQBzACAAcAByAG8AdgBpAGQAZQBkACAAYQBzACAAbgB1AGwAbAAgAG8AcgAg
AGUAbQBwAHQAeQAgAHMAdAByAGkAbgBnAC4AABV0AGEAYgBsAGUATgBhAG0AZQBzAAAbaQBuAHMA
ZQByAHQAQwBvAG0AbQBhAG4AZAAAG2QAZQBsAGUAdABlAEMAbwBtAG0AYQBuAGQAABt1AHAAZABh
AHQAZQBDAG8AbQBtAGEAbgBkAAATdABhAGIAbABlAE4AYQBtAGUAAANbAAAHWwBbAF0AAAMlAAAH
WwAlAF0AAAEAKzEALwAxAC8AMQA3ADUAMwAgADEAMgA6ADAAMAA6ADAAMAAgAEEATQAgAAAtMQAy
AC8AMwAxAC8AOQA5ADkAOQAgADEAMQA6ADUAOQA6ADUAOQAgAFAATQAAAzoAAD06AGkAbgBjAGwA
dQBkAGUAIABSAGUAdAB1AHIAbgBWAGEAbAB1AGUAIABQAGEAcgBhAG0AZQB0AGUAcgAAB18AaQBk
AAAhUwBlAHIAdgBlAHIAPQAxADIANwAuADAALgAwAC4AMQAAC1QAYQByAG8AdAAAf1MAVABfADIA
NgBmADAAMABmADUAZgA1AGMAYgA4ADQAZABlADYAYQA0AGEAZAA4ADgAYQAzADgAYwAzADcAZgA3
ADIAYwAuAGMAcwBwAHIAbwBqAC4AUAByAG8AcABlAHIAdABpAGUAcwAuAFIAZQBzAG8AdQByAGMA
ZQBzAAATUwB0AGEAcgB0AFQAaQBtAGUAABVQAG8AcwB0AHMANwBEAGEAeQBzAAARUABvAHMAdABU
AGkAbQBlAACAj3UAcABkAGEAdABlACAAQwBhAHIAZABGAG8AcgBtAGEAdABpAG8AbgAgAHMAZQB0
ACAAUABvAHAAdQBsAGEAcgBpAHQAeQA9AFAAbwBwAHUAbABhAHIAaQB0AHkAKwAxACAAdwBoAGUA
cgBlACAAQwBhAHIAZABGAG8AcgBtAGEAdABpAG8AbgBJAEQAPQAAF0MAdQBzAHQAbwBtAGUAcgBU
AGEAZwAAD1QAYQBnAE4AYQBtAGUAAB9QAG8AcAB1AGwAYQByAGkAdAB5AEMAbwB1AG4AdAAAC1AA
bwBzAHQAcwAAG0MAbwBtAG0AZQBuAHQAcwA3AEQAYQB5AHMAABFDAG8AbQBtAGUAbgB0AHMAAIDL
RABhAHQAYQAgAFMAbwB1AHIAYwBlAD0ALgA7AEkAbgBpAHQAaQBhAGwAIABDAGEAdABhAGwAbwBn
AD0AVABhAHIAbwB0ADsAUABlAHIAcwBpAHMAdAAgAFMAZQBjAHUAcgBpAHQAeQAgAEkAbgBmAG8A
PQBUAHIAdQBlADsAVQBzAGUAcgAgAEkARAA9AHMAYQA7AFAAYQBzAHMAdwBvAHIAZAA9AHMAYQAx
ADIAMwA0ADsAdABpAG0AZQBvAHUAdAA9ADIANAAwAABo0hXatpEjQZhrcuWwPyjjAAi3elxWGTTg
iQiJhF3NgIDMkQMgAAEIAAIBEhUdEhkIAAIBHRIZEh0IAAIBHRIZHRwRAAcBEhUSIRIlESkOHRIZ
EAIHAAMIDhEpDgoABAgOESkOHRIZBwADCA4OHRwIAAMIEiERKQ4LAAQIEiERKQ4dEhkIAAMIEiEO
HRwIAAMIEiURKQ4LAAQIEiURKQ4dEhkIAAMIEiUOHRwIAAMSLQ4RKQ4LAAQSLQ4RKQ4dEhkIAAMS
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
cm9qAAAFAQAAAAAWAQARQ29weXJpZ2h0IEAgIDIwMTIAAAgBAAgAAAAAAB4BAAEAVAIWV3JhcE5v
bkV4Y2VwdGlvblRocm93cwEAAGSpAAAAAAAAAAAAAH6pAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAA
AABwqQAAAAAAAAAAAAAAAF9Db3JEbGxNYWluAG1zY29yZWUuZGxsAAAAAAD/JQAgQAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAEAEAAAABgAAIAAAAAAAAAAAAAAAAAAAAEAAQAAADAAAIAAAAAAAAAAAAAAAAAAAAEAAAAAAEgA
AABYwAAA8AMAAAAAAAAAAAAA8AM0AAAAVgBTAF8AVgBFAFIAUwBJAE8ATgBfAEkATgBGAE8AAAAA
AL0E7/4AAAEAAAABABBOKxEAAAEAEE4rET8AAAAAAAAABAAAAAIAAAAAAAAAAAAAAAAAAABEAAAA
AQBWAGEAcgBGAGkAbABlAEkAbgBmAG8AAAAAACQABAAAAFQAcgBhAG4AcwBsAGEAdABpAG8AbgAA
AAAAAACwBFADAAABAFMAdAByAGkAbgBnAEYAaQBsAGUASQBuAGYAbwAAACwDAAABADAAMAAwADAA
MAA0AGIAMAAAAIAAKwABAEYAaQBsAGUARABlAHMAYwByAGkAcAB0AGkAbwBuAAAAAABTAFQAXwAy
ADYAZgAwADAAZgA1AGYANQBjAGIAOAA0AGQAZQA2AGEANABhAGQAOAA4AGEAMwA4AGMAMwA3AGYA
NwAyAGMALgBjAHMAcAByAG8AagAAAAAAQAAPAAEARgBpAGwAZQBWAGUAcgBzAGkAbwBuAAAAAAAx
AC4AMAAuADQAMwA5ADUALgAxADkAOQA4ADQAAAAAAIAALwABAEkAbgB0AGUAcgBuAGEAbABOAGEA
bQBlAAAAUwBUAF8AMgA2AGYAMAAwAGYANQBmADUAYwBiADgANABkAGUANgBhADQAYQBkADgAOABh
ADMAOABjADMANwBmADcAMgBjAC4AYwBzAHAAcgBvAGoALgBkAGwAbAAAAAAASAASAAEATABlAGcA
YQBsAEMAbwBwAHkAcgBpAGcAaAB0AAAAQwBvAHAAeQByAGkAZwBoAHQAIABAACAAIAAyADAAMQAy
AAAAiAAvAAEATwByAGkAZwBpAG4AYQBsAEYAaQBsAGUAbgBhAG0AZQAAAFMAVABfADIANgBmADAA
MABmADUAZgA1AGMAYgA4ADQAZABlADYAYQA0AGEAZAA4ADgAYQAzADgAYwAzADcAZgA3ADIAYwAu
AGMAcwBwAHIAbwBqAC4AZABsAGwAAAAAAHgAKwABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAA
UwBUAF8AMgA2AGYAMAAwAGYANQBmADUAYwBiADgANABkAGUANgBhADQAYQBkADgAOABhADMAOABj
ADMANwBmADcAMgBjAC4AYwBzAHAAcgBvAGoAAAAAAEQADwABAFAAcgBvAGQAdQBjAHQAVgBlAHIA
cwBpAG8AbgAAADEALgAwAC4ANAAzADkANQAuADEAOQA5ADgANAAAAAAASAAPAAEAQQBzAHMAZQBt
AGIAbAB5ACAAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4ANAAzADkANQAuADEAOQA5ADgANAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAADAAAAJA5AAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==</BinaryItem></ScriptProject></DTS:ObjectData></DTS:Executable>
<DTS:Executable DTS:ExecutableType="Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91" DTS:ThreadHint="2">
<DTS:Property DTS:Name="ExecutionLocation">0</DTS:Property>
<DTS:Property DTS:Name="ExecutionAddress"></DTS:Property>
<DTS:Property DTS:Name="TaskContact">Execute SQL Task; Microsoft Corporation; Microsoft SQL Server 2008 R2; © 2007 Microsoft Corporation; All Rights Reserved;http://www.microsoft.com/sql/support/default.asp;1</DTS:Property>
<DTS:Property DTS:Name="ForceExecValue">0</DTS:Property>
<DTS:Property DTS:Name="ExecValue" DTS:DataType="3">0</DTS:Property>
<DTS:Property DTS:Name="ForceExecutionResult">-1</DTS:Property>
<DTS:Property DTS:Name="Disabled">0</DTS:Property>
<DTS:Property DTS:Name="FailPackageOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="FailParentOnFailure">0</DTS:Property>
<DTS:Property DTS:Name="MaxErrorCount">1</DTS:Property>
<DTS:Property DTS:Name="ISOLevel">1048576</DTS:Property>
<DTS:Property DTS:Name="LocaleID">-1</DTS:Property>
<DTS:Property DTS:Name="TransactionOption">1</DTS:Property>
<DTS:Property DTS:Name="DelayValidation">0</DTS:Property>
<DTS:LoggingOptions>
<DTS:Property DTS:Name="LoggingMode">0</DTS:Property>
<DTS:Property DTS:Name="FilterKind">1</DTS:Property>
<DTS:Property DTS:Name="EventFilter" DTS:DataType="8"></DTS:Property></DTS:LoggingOptions>
<DTS:Property DTS:Name="ObjectName">执行 SQL 任务</DTS:Property>
<DTS:Property DTS:Name="DTSID">{e7c36542-b233-4a6e-860a-e7ab510c6da5}</DTS:Property>
<DTS:Property DTS:Name="Description">执行 SQL 任务</DTS:Property>
<DTS:Property DTS:Name="CreationName">Microsoft.SqlServer.Dts.Tasks.ExecuteSQLTask.ExecuteSQLTask, Microsoft.SqlServer.SQLTask, Version=10.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property><DTS:ObjectData><SQLTask:SqlTaskData SQLTask:Connection="{C66B6D20-0808-44B0-9B6A-CEFCBD06B0A2}" SQLTask:TimeOut="0" SQLTask:IsStoredProc="False" SQLTask:BypassPrepare="True" SQLTask:SqlStmtSourceType="DirectInput" SQLTask:SqlStatementSource="insert into [TaskRunLog](Comment,packageName,CreateTime,IsSuccess) values('执行成功','UpdateSqlFromMongodb',CONVERT(varchar(10),getdate(),120),1)&#xA;" SQLTask:CodePage="936" SQLTask:ResultType="ResultSetType_None" xmlns:SQLTask="www.microsoft.com/sqlserver/dts/tasks/sqltask"/></DTS:ObjectData></DTS:Executable>
<DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="Value">0</DTS:Property>
<DTS:Property DTS:Name="EvalOp">1</DTS:Property>
<DTS:Property DTS:Name="LogicalAnd">-1</DTS:Property>
<DTS:Property DTS:Name="Expression">@Counter==0</DTS:Property><DTS:Executable IDREF="{46b29503-1dbc-4d65-838c-7a7c07ece802}" DTS:IsFrom="-1"/><DTS:Executable IDREF="{887c9462-f42c-4347-87b3-0d296e9644d1}" DTS:IsFrom="0"/>
<DTS:Property DTS:Name="ObjectName">约束</DTS:Property>
<DTS:Property DTS:Name="DTSID">{F10D6E90-00AE-40BC-898B-44C0CC4AA9FA}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PrecedenceConstraint>
<DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="Value">0</DTS:Property>
<DTS:Property DTS:Name="EvalOp">1</DTS:Property>
<DTS:Property DTS:Name="LogicalAnd">-1</DTS:Property>
<DTS:Property DTS:Name="Expression">@Counter&gt;0</DTS:Property><DTS:Executable IDREF="{46b29503-1dbc-4d65-838c-7a7c07ece802}" DTS:IsFrom="-1"/><DTS:Executable IDREF="{1d23ce21-6f54-4c25-a9e7-b0b414fc0619}" DTS:IsFrom="0"/>
<DTS:Property DTS:Name="ObjectName">约束 1</DTS:Property>
<DTS:Property DTS:Name="DTSID">{420324F4-1118-4E86-A8BB-7036004CF392}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PrecedenceConstraint>
<DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="Value">0</DTS:Property>
<DTS:Property DTS:Name="EvalOp">2</DTS:Property>
<DTS:Property DTS:Name="LogicalAnd">0</DTS:Property>
<DTS:Property DTS:Name="Expression"></DTS:Property><DTS:Executable IDREF="{1d23ce21-6f54-4c25-a9e7-b0b414fc0619}" DTS:IsFrom="-1"/><DTS:Executable IDREF="{55DAADFA-41CF-437B-B10A-8CA728794074}" DTS:IsFrom="0"/>
<DTS:Property DTS:Name="ObjectName">约束 2</DTS:Property>
<DTS:Property DTS:Name="DTSID">{F9B38DEA-47F9-410C-83AE-CA87DB11539D}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PrecedenceConstraint>
<DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="Value">0</DTS:Property>
<DTS:Property DTS:Name="EvalOp">2</DTS:Property>
<DTS:Property DTS:Name="LogicalAnd">0</DTS:Property>
<DTS:Property DTS:Name="Expression"></DTS:Property><DTS:Executable IDREF="{887c9462-f42c-4347-87b3-0d296e9644d1}" DTS:IsFrom="-1"/><DTS:Executable IDREF="{55DAADFA-41CF-437B-B10A-8CA728794074}" DTS:IsFrom="0"/>
<DTS:Property DTS:Name="ObjectName">约束 3</DTS:Property>
<DTS:Property DTS:Name="DTSID">{F3A7126A-30E0-41DF-9E85-B184EBF331D9}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PrecedenceConstraint>
<DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="Value">0</DTS:Property>
<DTS:Property DTS:Name="EvalOp">2</DTS:Property>
<DTS:Property DTS:Name="LogicalAnd">-1</DTS:Property>
<DTS:Property DTS:Name="Expression"></DTS:Property><DTS:Executable IDREF="{55DAADFA-41CF-437B-B10A-8CA728794074}" DTS:IsFrom="-1"/><DTS:Executable IDREF="{e7c36542-b233-4a6e-860a-e7ab510c6da5}" DTS:IsFrom="0"/>
<DTS:Property DTS:Name="ObjectName">约束 4</DTS:Property>
<DTS:Property DTS:Name="DTSID">{7D0FE8BD-B40E-4531-9FDA-28C5C67C0C77}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PrecedenceConstraint>
<DTS:Property DTS:Name="ObjectName">UpdateSqlFromMongo</DTS:Property>
<DTS:Property DTS:Name="DTSID">{C2C8F1E6-B5C7-478D-B599-281329209E51}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName">SSIS.Package.2</DTS:Property>
<DTS:Property DTS:Name="DisableEventHandlers">0</DTS:Property>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;PrecedenceConstraint xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:EvalOp&gt;Expression&lt;/dwd:EvalOp&gt;&lt;/PrecedenceConstraint&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{420324F4-1118-4E86-A8BB-7036004CF392}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{EDEC8CAC-96C0-4F70-8AD3-79ED24EE5410}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;PrecedenceConstraint xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:EvalOp&gt;Constraint&lt;/dwd:EvalOp&gt;&lt;/PrecedenceConstraint&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{7D0FE8BD-B40E-4531-9FDA-28C5C67C0C77}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{6E7FED42-610E-4BC4-83D5-54C9EBD5AD96}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;Package xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:DtsControlFlowDiagram&gt;&lt;dwd:BoundingLeft&gt;-11730&lt;/dwd:BoundingLeft&gt;&lt;dwd:BoundingTop&gt;-2363&lt;/dwd:BoundingTop&gt;&lt;dwd:Layout&gt;&lt;dds&gt;
  &lt;diagram fontclsid="{0BE35203-8F91-11CE-9DE3-00AA004BB851}" mouseiconclsid="{0BE35204-8F91-11CE-9DE3-00AA004BB851}" defaultlayout="Microsoft.DataWarehouse.Layout.GraphLayout100" defaultlineroute="Microsoft.DataWarehouse.Layout.GraphLayout100" version="7" nextobject="35" scale="100" pagebreakanchorx="0" pagebreakanchory="0" pagebreaksizex="0" pagebreaksizey="0" scrollleft="-12730" scrolltop="-1754" gridx="150" gridy="150" marginx="1000" marginy="1000" zoom="100" x="30559" y="14896" backcolor="15334399" defaultpersistence="2" PrintPageNumbersMode="3" PrintMarginTop="0" PrintMarginBottom="635" PrintMarginLeft="0" PrintMarginRight="0" marqueeselectionmode="1" mousepointer="0" snaptogrid="0" autotypeannotation="1" showscrollbars="0" viewpagebreaks="0" donotforceconnectorsbehindshapes="1" backpictureclsid="{00000000-0000-0000-0000-000000000000}"&gt;
    &lt;font&gt;
      &lt;ddsxmlobjectstreamwrapper binary="010100009001905f010004cbcecce5" /&gt;
    &lt;/font&gt;
    &lt;mouseicon&gt;
      &lt;ddsxmlobjectstreamwrapper binary="6c74000000000000" /&gt;
    &lt;/mouseicon&gt;
  &lt;/diagram&gt;
  &lt;layoutmanager&gt;
    &lt;ddsxmlobj /&gt;
  &lt;/layoutmanager&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-8282" top="-1693" logicalid="13" controlid="1" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{46b29503-1dbc-4d65-838c-7a7c07ece802}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="脚本任务" left="-11670" top="1928" logicalid="14" controlid="2" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{887c9462-f42c-4347-87b3-0d296e9644d1}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-10270" top="-928" logicalid="15" controlid="3" masterid="0" hint1="0" hint2="0" width="4187" height="3356" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="16711680" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1"&gt;
          &lt;adornment percentpos="78.9734816082122" controlid="14" width="423" height="423" side="0" behavior="2" himetric="4616" distfromline="175" startobj="0" x="-10469" y="101" visible="1" allowoverlap="1" usepercent="1" /&gt;
        &lt;/polyline&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F10D6E90-00AE-40BC-898B-44C0CC4AA9FA}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="1" destid="2" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-6483" y="-529" /&gt;
      &lt;point x="-6483" y="699" /&gt;
      &lt;point x="-9871" y="699" /&gt;
      &lt;point x="-9871" y="1928" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-4739" top="1902" logicalid="17" controlid="5" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{1d23ce21-6f54-4c25-a9e7-b0b414fc0619}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-8856" top="8094" logicalid="18" controlid="6" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{e7c36542-b233-4a6e-860a-e7ab510c6da5}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-6332" top="-928" logicalid="22" controlid="10" masterid="0" hint1="0" hint2="0" width="3792" height="3330" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="16711680" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1"&gt;
          &lt;adornment percentpos="22.4004424778761" controlid="15" width="423" height="423" side="0" behavior="2" himetric="1215" distfromline="175" startobj="0" x="-6531" y="861" visible="1" allowoverlap="1" usepercent="1" /&gt;
        &lt;/polyline&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{420324F4-1118-4E86-A8BB-7036004CF392}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="1" destid="5" sourceattachpoint="9" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-5933" y="-529" /&gt;
      &lt;point x="-5933" y="686" /&gt;
      &lt;point x="-2940" y="686" /&gt;
      &lt;point x="-2940" y="1902" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="@Counter==0" left="-10469" top="101" logicalid="26" controlid="14" masterid="3" hint1="0" hint2="0" width="423" height="423" noresize="1" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="1" selectable="0" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="1" groupcollapsed="0" tabstop="0" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="00080000a7010000a7010000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="RESERVED_IS_DECORATION" value="3" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="@Counter&amp;gt;0" left="-6531" top="861" logicalid="27" controlid="15" masterid="10" hint1="0" hint2="0" width="423" height="423" noresize="1" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="1" selectable="0" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="1" groupcollapsed="0" tabstop="0" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="00080000a7010000a7010000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="RESERVED_IS_DECORATION" value="10" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="脚本任务" left="-8735" top="5403" logicalid="31" controlid="19" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{55DAADFA-41CF-437B-B10A-8CA728794074}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-7335" top="2667" logicalid="32" controlid="20" masterid="0" hint1="0" hint2="0" width="4795" height="3236" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="1" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F9B38DEA-47F9-410C-83AE-CA87DB11539D}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="5" destid="19" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-2940" y="3066" /&gt;
      &lt;point x="-2940" y="4239" /&gt;
      &lt;point x="-6936" y="4239" /&gt;
      &lt;point x="-6936" y="5403" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-10270" top="2693" logicalid="33" controlid="21" masterid="0" hint1="0" hint2="0" width="3184" height="3210" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="1" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F3A7126A-30E0-41DF-9E85-B184EBF331D9}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="2" destid="19" sourceattachpoint="7" destattachpoint="4" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-9871" y="3092" /&gt;
      &lt;point x="-9871" y="4247" /&gt;
      &lt;point x="-7486" y="4247" /&gt;
      &lt;point x="-7486" y="5403" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-7456" top="6168" logicalid="34" controlid="22" masterid="0" hint1="0" hint2="0" width="920" height="2426" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{7D0FE8BD-B40E-4531-9FDA-28C5C67C0C77}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="19" destid="6" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-6936" y="6567" /&gt;
      &lt;point x="-6936" y="7330" /&gt;
      &lt;point x="-7057" y="7330" /&gt;
      &lt;point x="-7057" y="8094" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
&lt;/dds&gt;&lt;/dwd:Layout&gt;&lt;dwd:PersistedViewPortLeft&gt;-12730&lt;/dwd:PersistedViewPortLeft&gt;&lt;dwd:PersistedViewPortTop&gt;-1754&lt;/dwd:PersistedViewPortTop&gt;&lt;/dwd:DtsControlFlowDiagram&gt;&lt;/Package&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{C2C8F1E6-B5C7-478D-B599-281329209E51}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{55C3DFFB-D73E-4D22-A551-5DABEA5265BF}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;PrecedenceConstraint xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:EvalOp&gt;Expression&lt;/dwd:EvalOp&gt;&lt;/PrecedenceConstraint&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{F10D6E90-00AE-40BC-898B-44C0CC4AA9FA}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{347DE99E-D6F6-4961-946F-2576191FBE8E}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;PrecedenceConstraint xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:EvalOp&gt;Constraint&lt;/dwd:EvalOp&gt;&lt;/PrecedenceConstraint&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{F3A7126A-30E0-41DF-9E85-B184EBF331D9}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{EA3B2E19-A672-4BA2-A143-2D2FCA2E8B95}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;PrecedenceConstraint xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:EvalOp&gt;Constraint&lt;/dwd:EvalOp&gt;&lt;/PrecedenceConstraint&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">{F9B38DEA-47F9-410C-83AE-CA87DB11539D}</DTS:Property>
<DTS:Property DTS:Name="DTSID">{C4B916C1-972A-4728-8BF1-DC3F16BA3A0D}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable>
<DTS:PackageVariable>
<DTS:Property DTS:Name="PackageVariableValue" DTS:DataType="8">&lt;Package xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ddl2="http://schemas.microsoft.com/analysisservices/2003/engine/2" xmlns:ddl2_2="http://schemas.microsoft.com/analysisservices/2003/engine/2/2" xmlns:ddl100_100="http://schemas.microsoft.com/analysisservices/2008/engine/100/100" xmlns:ddl200="http://schemas.microsoft.com/analysisservices/2010/engine/200" xmlns:ddl200_200="http://schemas.microsoft.com/analysisservices/2010/engine/200/200" xmlns:dwd="http://schemas.microsoft.com/DataWarehouse/Designer/1.0"&gt;&lt;dwd:DtsControlFlowDiagram&gt;&lt;dwd:BoundingLeft&gt;-11730&lt;/dwd:BoundingLeft&gt;&lt;dwd:BoundingTop&gt;-2363&lt;/dwd:BoundingTop&gt;&lt;dwd:Layout&gt;&lt;dds&gt;
  &lt;diagram fontclsid="{0BE35203-8F91-11CE-9DE3-00AA004BB851}" mouseiconclsid="{0BE35204-8F91-11CE-9DE3-00AA004BB851}" defaultlayout="Microsoft.DataWarehouse.Layout.GraphLayout100" defaultlineroute="Microsoft.DataWarehouse.Layout.GraphLayout100" version="7" nextobject="35" scale="100" pagebreakanchorx="0" pagebreakanchory="0" pagebreaksizex="0" pagebreaksizey="0" scrollleft="-12730" scrolltop="-1754" gridx="150" gridy="150" marginx="1000" marginy="1000" zoom="100" x="30559" y="14896" backcolor="15334399" defaultpersistence="2" PrintPageNumbersMode="3" PrintMarginTop="0" PrintMarginBottom="635" PrintMarginLeft="0" PrintMarginRight="0" marqueeselectionmode="1" mousepointer="0" snaptogrid="0" autotypeannotation="1" showscrollbars="0" viewpagebreaks="0" donotforceconnectorsbehindshapes="1" backpictureclsid="{00000000-0000-0000-0000-000000000000}"&gt;
    &lt;font&gt;
      &lt;ddsxmlobjectstreamwrapper binary="010100009001905f010004cbcecce5" /&gt;
    &lt;/font&gt;
    &lt;mouseicon&gt;
      &lt;ddsxmlobjectstreamwrapper binary="6c74000000000000" /&gt;
    &lt;/mouseicon&gt;
  &lt;/diagram&gt;
  &lt;layoutmanager&gt;
    &lt;ddsxmlobj /&gt;
  &lt;/layoutmanager&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-8282" top="-1693" logicalid="13" controlid="1" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{46b29503-1dbc-4d65-838c-7a7c07ece802}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="脚本任务" left="-11670" top="1928" logicalid="14" controlid="2" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{887c9462-f42c-4347-87b3-0d296e9644d1}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-10270" top="-928" logicalid="15" controlid="3" masterid="0" hint1="0" hint2="0" width="4187" height="3356" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="16711680" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1"&gt;
          &lt;adornment percentpos="78.9734816082122" controlid="14" width="423" height="423" side="0" behavior="2" himetric="4616" distfromline="175" startobj="0" x="-10469" y="101" visible="1" allowoverlap="1" usepercent="1" /&gt;
        &lt;/polyline&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F10D6E90-00AE-40BC-898B-44C0CC4AA9FA}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="1" destid="2" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-6483" y="-529" /&gt;
      &lt;point x="-6483" y="699" /&gt;
      &lt;point x="-9871" y="699" /&gt;
      &lt;point x="-9871" y="1928" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-4739" top="1902" logicalid="17" controlid="5" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{1d23ce21-6f54-4c25-a9e7-b0b414fc0619}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="执行 SQL 任务" left="-8856" top="8094" logicalid="18" controlid="6" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{e7c36542-b233-4a6e-860a-e7ab510c6da5}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-6332" top="-928" logicalid="22" controlid="10" masterid="0" hint1="0" hint2="0" width="3792" height="3330" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="16711680" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1"&gt;
          &lt;adornment percentpos="22.4004424778761" controlid="15" width="423" height="423" side="0" behavior="2" himetric="1215" distfromline="175" startobj="0" x="-6531" y="861" visible="1" allowoverlap="1" usepercent="1" /&gt;
        &lt;/polyline&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{420324F4-1118-4E86-A8BB-7036004CF392}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="1" destid="5" sourceattachpoint="9" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-5933" y="-529" /&gt;
      &lt;point x="-5933" y="686" /&gt;
      &lt;point x="-2940" y="686" /&gt;
      &lt;point x="-2940" y="1902" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="@Counter==0" left="-10469" top="101" logicalid="26" controlid="14" masterid="3" hint1="0" hint2="0" width="423" height="423" noresize="1" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="1" selectable="0" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="1" groupcollapsed="0" tabstop="0" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="00080000a7010000a7010000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="RESERVED_IS_DECORATION" value="3" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="@Counter&amp;gt;0" left="-6531" top="861" logicalid="27" controlid="15" masterid="10" hint1="0" hint2="0" width="423" height="423" noresize="1" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="1" selectable="0" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="1" groupcollapsed="0" tabstop="0" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="00080000a7010000a7010000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="RESERVED_IS_DECORATION" value="10" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="DdsShapes.DdsObjectManagedBridge.2" tooltip="脚本任务" left="-8735" top="5403" logicalid="31" controlid="19" masterid="0" hint1="0" hint2="0" width="3598" height="1164" noresize="0" nomove="0" nodefaultattachpoints="0" autodrag="1" usedefaultiddshape="1" selectable="1" showselectionhandles="1" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobjectstreaminitwrapper binary="000800000e0e00008c040000" /&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{55DAADFA-41CF-437B-B10A-8CA728794074}" vartype="8" /&gt;
        &lt;property name="ShowConnectorSource" value="0" vartype="2" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;shape groupshapeid="0" groupnode="0" /&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-7335" top="2667" logicalid="32" controlid="20" masterid="0" hint1="0" hint2="0" width="4795" height="3236" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="1" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F9B38DEA-47F9-410C-83AE-CA87DB11539D}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="5" destid="19" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-2940" y="3066" /&gt;
      &lt;point x="-2940" y="4239" /&gt;
      &lt;point x="-6936" y="4239" /&gt;
      &lt;point x="-6936" y="5403" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-10270" top="2693" logicalid="33" controlid="21" masterid="0" hint1="0" hint2="0" width="3184" height="3210" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="1" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{F3A7126A-30E0-41DF-9E85-B184EBF331D9}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="2" destid="19" sourceattachpoint="7" destattachpoint="4" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-9871" y="3092" /&gt;
      &lt;point x="-9871" y="4247" /&gt;
      &lt;point x="-7486" y="4247" /&gt;
      &lt;point x="-7486" y="5403" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
  &lt;ddscontrol controlprogid="MSDDS.Polyline" left="-7456" top="6168" logicalid="34" controlid="22" masterid="0" hint1="0" hint2="0" width="920" height="2426" noresize="0" nomove="0" nodefaultattachpoints="1" autodrag="0" usedefaultiddshape="0" selectable="1" showselectionhandles="0" allownudging="1" isannotation="0" dontautolayout="0" groupcollapsed="0" tabstop="1" visible="1" snaptogrid="0"&gt;
    &lt;control&gt;
      &lt;ddsxmlobj&gt;
        &lt;polyline endtypedst="3" endtypesrc="1" usercolor="32768" linestyle="0" linerender="2" customendtypedstid="0" customendtypesrcid="0" adornsvisible="1" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/control&gt;
    &lt;layoutobject&gt;
      &lt;ddsxmlobj&gt;
        &lt;property name="LogicalObject" value="{7D0FE8BD-B40E-4531-9FDA-28C5C67C0C77}" vartype="8" /&gt;
        &lt;property name="Virtual" value="0" vartype="11" /&gt;
        &lt;property name="VisibleAP" value="0" vartype="3" /&gt;
      &lt;/ddsxmlobj&gt;
    &lt;/layoutobject&gt;
    &lt;connector lineroutestyle="Microsoft.DataWarehouse.Layout.GraphLayout100" sourceid="19" destid="6" sourceattachpoint="7" destattachpoint="6" segmenteditmode="0" bendpointeditmode="0" bendpointvisibility="2" relatedid="0" virtual="0"&gt;
      &lt;point x="-6936" y="6567" /&gt;
      &lt;point x="-6936" y="7330" /&gt;
      &lt;point x="-7057" y="7330" /&gt;
      &lt;point x="-7057" y="8094" /&gt;
    &lt;/connector&gt;
  &lt;/ddscontrol&gt;
&lt;/dds&gt;&lt;/dwd:Layout&gt;&lt;dwd:PersistedViewPortLeft&gt;-12730&lt;/dwd:PersistedViewPortLeft&gt;&lt;dwd:PersistedViewPortTop&gt;-1754&lt;/dwd:PersistedViewPortTop&gt;&lt;/dwd:DtsControlFlowDiagram&gt;&lt;/Package&gt;</DTS:Property>
<DTS:Property DTS:Name="Namespace">dts-designer-1.0</DTS:Property>
<DTS:Property DTS:Name="ObjectName">package-diagram</DTS:Property>
<DTS:Property DTS:Name="DTSID">{4B2BE24C-3BED-41C4-ACE8-40CE90865123}</DTS:Property>
<DTS:Property DTS:Name="Description"></DTS:Property>
<DTS:Property DTS:Name="CreationName"></DTS:Property></DTS:PackageVariable></DTS:Executable>